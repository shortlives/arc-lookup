<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ARC Lookup</title>

  <!-- MetaForge tooltips script (for item/quest hover tooltips) -->
  <script async src="https://cdn.metaforge.app/arcraiders-tooltips.min.js"></script>

  <style>
    body {
      background:#000;
      color:#fff;
      font-family:Segoe UI, sans-serif;
      padding:20px;
      max-width:900px;
      margin:0 auto;
    }

    .top-buttons {
      display:flex;
      gap:10px;
      margin-bottom:15px;
      flex-wrap:wrap;
    }
    .top-buttons a,
    .top-buttons button {
      background:#222;
      color:#fff;
      border:1px solid #444;
      border-radius:6px;
      padding:6px 12px;
      font-size:14px;
      text-decoration:none;
      cursor:pointer;
    }
    .top-buttons a:hover,
    .top-buttons button:hover {
      background:#333;
    }

    .search-row {
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }

    #search {
      font-size:22px;
      padding:12px;
      flex:1;
    }

    #clear-search {
      font-size:18px;
      padding:10px 14px;
      border-radius:6px;
      border:1px solid #444;
      background:#222;
      color:#fff;
      cursor:pointer;
    }
    #clear-search:hover {
      background:#333;
    }

    .instructions {
      background:#111;
      border:1px solid #333;
      border-radius:8px;
      padding:10px 12px;
      font-size:13px;
      margin-bottom:12px;
    }
    .instructions-title {
      font-weight:bold;
      margin-bottom:4px;
    }
    .instructions-row {
      margin:3px 0;
    }
    .pill {
      display:inline-block;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid #444;
      margin-left:4px;
      font-size:12px;
    }

    /* Rarity color pills (match item title colors) */
    .pill-common   { color:#ffffff; }
    .pill-uncommon { color:#00ff00; }
    .pill-rare     { color:#00bfff; }
    .pill-epic     { color:#ff00ff; }
    .pill-legendary{ color:#ffd700; }

    /* Value color pills (match price color logic) */
    .pill-price-1  { color:#ffffff; } /* ≤ 1000 */
    .pill-price-2  { color:#00ff00; } /* 1001–2000 */
    .pill-price-3  { color:#ff69b4; } /* 2001–5000 */
    .pill-price-4  { color:#ffd700; } /* 5001+ */

    .hidden {
      display:none !important;
    }

    .item-block {
      margin:10px 0 14px 0;
    }

    .item-title {
      font-size:26px;
      font-weight:bold;
      margin-bottom:4px;
    }

    .item-link {
      text-decoration:none;
    }

    .item-value {
      font-size:20px;
      margin-left:6px;
    }

    .quest-tag {
      font-size:16px;
      margin-left:8px;
      color:#ffd700;
    }

    .line {
      margin:4px 0;
      font-size:18px;
    }

    .line-small {
      font-size:14px;
      color:#ccc;
    }

    .rarity-letter {
      display:inline-block;
      width:18px;
      text-align:center;
      margin-left:4px;
      font-weight:bold;
    }

    .notes-panel {
      background:#111;
      border:1px solid #333;
      border-radius:8px;
      padding:10px 12px;
      margin-bottom:12px;
      font-size:14px;
    }

    .notes-panel h2 {
      margin-top:0;
      font-size:18px;
    }

    .note-item {
      margin:4px 0;
    }

    hr {
      border:1px solid #333;
      margin:10px 0;
    }

    .error {
      color:#ff6666;
    }

    footer {
      margin-top:16px;
      font-size:12px;
      color:#888;
    }
    footer a {
      color:#66b3ff;
    }
  </style>
</head>
<body>
  <div class="top-buttons" id="topButtons">
    <a href="https://mapgenie.io/arc-raiders" target="_blank" rel="noopener noreferrer">Maps</a>
    <a href="https://docs.google.com/spreadsheets/d/1FYBQG7Zq-hb-73baiUtMGrUUUjtif3mbBUZcpHN2X3U/edit?gid=732163012#gid=732163012"
       target="_blank" rel="noopener noreferrer">Spreadsheet</a>
    <button type="button" id="notesToggle">Important Notes</button>
  </div>

  <div class="search-row">
    <input id="search" placeholder="Type item name..." autofocus>
    <button id="clear-search" type="button" aria-label="Clear search">×</button>
  </div>

  <!-- Shown only when there is text in the search box -->
  <div id="instructions" class="instructions hidden">
    <div class="instructions-title">How to read the colors</div>
    <div class="instructions-row">
      Item name (rarity):
      <span class="pill pill-common">Common</span>
      <span class="pill pill-uncommon">Uncommon</span>
      <span class="pill pill-rare">Rare</span>
      <span class="pill pill-epic">Epic</span>
      <span class="pill pill-legendary">Legendary</span>
    </div>
    <div class="instructions-row">
      Sell value:
      <span class="pill pill-price-1">≤ 1000</span>
      <span class="pill pill-price-2">1001–2000</span>
      <span class="pill pill-price-3">2001–5000</span>
      <span class="pill pill-price-4">5001+</span>
    </div>
    <div class="instructions-row">
      R / S tags:
      <span class="pill">R-# = from recycling · S-# = from salvaging</span>
    </div>
  </div>

  <!-- Important Notes (Google Sheet "Important Notes" tab) -->
  <div id="notesPanel" class="notes-panel hidden">
    <h2>Important Notes</h2>
    <div id="notesContent">Loading…</div>
  </div>

  <div id="result"></div>

  <footer>
    Data from the
    <a href="https://metaforge.app/arc-raiders" target="_blank" rel="noopener noreferrer">MetaForge ARC Raiders</a>
    API &amp; your Google Sheet.
  </footer>

<script>
"use strict";

/**
 * CONFIGURATION
 *
 * items.json / quests.json should live in the same directory as this file.
 * EXTRA_CSV_URL is your existing "items" sheet (for recycle1/2 + notes).
 * NOTES_CSV_URL should be a published CSV for your "Important Notes" tab.
 */
const ITEMS_API_URL  = "./items.json";
const QUESTS_API_URL = "./quests.json";

const EXTRA_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ8XIQtZGS9iURh9D5oWsgyyBMqNJkLy9x0olt6DKKlCHevSpZ3qQevYZjrpctOLjOUyDFv1HEjkqGq/pub?output=csv";

// TODO: update once you publish the Important Notes tab as CSV
const NOTES_CSV_URL = ""; // e.g. "https://docs.google.com/...&single=true&output=csv"

/**
 * GLOBAL STATE
 */
const state = {
  items: [],                         // merged item objects (API + sheet overlay)
  itemByName: new Map(),             // normalized name -> item
  extrasByName: new Map(),           // normalized name -> extra row from sheet
  itemIdToRequiredQuests: new Map(), // item id -> quest list
  itemIdToRewardQuests: new Map(),   // item id -> quest list
  itemNameToRequiredQuests: new Map(), // normalized item name -> quest list
  itemNameToRewardQuests: new Map(),   // normalized item name -> quest list
  importantNotes: [],
  dataLoaded: false,
  notesLoaded: false,
  notesError: null
};

// DOM cache
const dom = {
  search:       document.getElementById("search"),
  clearSearch:  document.getElementById("clear-search"),
  topButtons:   document.getElementById("topButtons"),
  instructions: document.getElementById("instructions"),
  result:       document.getElementById("result"),
  notesPanel:   document.getElementById("notesPanel"),
  notesContent: document.getElementById("notesContent"),
  notesToggle:  document.getElementById("notesToggle")
};

/**
 * UTILITIES
 */

// Normalize item names for matching
function normalizeName(str) {
  return (str || "").trim().toLowerCase();
}

// Slugify quest names if we need a URL slug and API didn't give one
function slugifyName(str) {
  return (str || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

// Basic HTML escaping
function escapeHtml(str) {
  return (str || "").replace(/[&<>"']/g, ch => {
    switch (ch) {
      case "&": return "&amp;";
      case "<": return "&lt;";
      case ">": return "&gt;";
      case '"': return "&quot;";
      case "'": return "&#39;";
      default:  return ch;
    }
  });
}

// Parse CSV line
function csvSplit(row) {
  const out = [];
  let field = "";
  let inQuotes = false;

  for (const ch of row) {
    if (ch === '"') {
      inQuotes = !inQuotes;
      continue;
    }
    if (ch === "," && !inQuotes) {
      out.push(field);
      field = "";
      continue;
    }
    field += ch;
  }
  out.push(field);
  return out;
}

// Rarity color (item title)
function rarityColor(rarity) {
  const r = (rarity || "").toLowerCase();
  if (r.includes("uncommon"))  return "#00ff00";
  if (r.includes("rare"))      return "#00bfff";
  if (r.includes("epic"))      return "#ff00ff";
  if (r.includes("legendary")) return "#ffd700";
  return "#ffffff";
}

// Rarity letter + color (for R-letter badges)
function rarityLetterAndColor(rarity) {
  const r = (rarity || "").toLowerCase();
  if (r.includes("legendary")) return { letter: "L", color: "#ffd700" };
  if (r.includes("epic"))      return { letter: "E", color: "#ff00ff" };
  if (r.includes("rare"))      return { letter: "R", color: "#00bfff" };
  if (r.includes("uncommon"))  return { letter: "U", color: "#00ff00" };
  return { letter: "C", color: "#ffffff" };
}

// Value color based on price
function priceColor(value) {
  const n = Number(value) || 0;
  if (n <= 1000)  return "#ffffff";
  if (n <= 2000)  return "#00ff00";
  if (n <= 5000)  return "#ff69b4";
  return "#ffd700";
}

// Parse recycle entries like "3 x Advanced Electrical Components"
function parseRecycleEntry(entry) {
  if (!entry) return null;
  const trimmed = entry.trim();
  if (!trimmed) return null;

  const m = trimmed.match(/^\s*(\d+)\s*x?\s*(.+)$/i);
  if (!m) {
    return { qty: null, itemName: trimmed };
  }
  return {
    qty: parseInt(m[1], 10),
    itemName: m[2].trim()
  };
}

/**
 * DATA LOADING
 */

async function init() {
  dom.result.textContent = "Loading item data…";

  attachEventHandlers();

  try {
    const [itemsJson, questsJson, extraCsv] = await Promise.all([
      fetchJson(ITEMS_API_URL),
      fetchJson(QUESTS_API_URL),
      fetchTextSafe(EXTRA_CSV_URL)
    ]);

    if (extraCsv) {
      parseExtraCsv(extraCsv);
    }

    buildItemsFromApi(itemsJson);
    buildQuestIndex(questsJson);

    state.dataLoaded = true;
    dom.result.textContent = "Type an item name above to search.";
  } catch (err) {
    console.error(err);
    dom.result.innerHTML =
      '<div class="error">Error loading data from items.json / quests.json or your sheet. Check the console and URLs.</div>';
  }
}

// Basic JSON fetch
async function fetchJson(url) {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error("Failed to fetch JSON: " + url + " (" + res.status + ")");
  }
  return res.json();
}

// Text fetch that fails silently (returns null) on error
async function fetchTextSafe(url) {
  if (!url) return null;
  try {
    const res = await fetch(url);
    if (!res.ok) return null;
    return res.text();
  } catch {
    return null;
  }
}

// Overlay CSV for recycle/notes
function parseExtraCsv(csvText) {
  const rows = csvText.replace(/\r/g, "").split("\n");
  rows.shift(); // header

  for (const row of rows) {
    if (!row.trim()) continue;
    const fields = csvSplit(row);

    const extra = {
      name:      fields[0] || "",
      rarity:    fields[1] || "",
      recycle1:  fields[2] || "",
      recycle2:  fields[3] || "",
      sellPrice: fields[4] || "",
      category:  fields[5] || "",
      keep1:     fields[6] || "",
      keep2:     fields[7] || "",
      keep3:     fields[8] || "",
      notes:     fields[9] || ""
    };

    const key = normalizeName(extra.name);
    if (!key) continue;
    state.extrasByName.set(key, extra);
  }
}

// Merge items API + overlay CSV
function buildItemsFromApi(itemsJson) {
  const apiItems = Array.isArray(itemsJson?.data) ? itemsJson.data : [];

  const usedExtraKeys = new Set();
  const mergedItems = [];

  // 1) Items that exist in API
  for (const it of apiItems) {
    const key = normalizeName(it.name);
    const extra = state.extrasByName.get(key);

    if (extra) {
      usedExtraKeys.add(key);
    }

    const merged = {
      // API
      id: it.id,
      name: it.name,
      rarity: it.rarity || extra?.rarity || "",
      value: typeof it.value === "number"
        ? it.value
        : (extra ? parseInt(extra.sellPrice.replace(/[^0-9]/g, ""), 10) || 0 : 0),
      itemType: it.item_type || extra?.category || "",
      workbench: it.workbench || "",
      flavorText: it.flavor_text || "",
      lootArea: it.loot_area || "",

      // Overlay
      recycle1: extra?.recycle1 || "",
      recycle2: extra?.recycle2 || "",
      extraNotes: extra?.notes || ""
    };

    mergedItems.push(merged);
    state.itemByName.set(key, merged);
  }

  // 2) Extra sheet-only rows
  for (const [key, extra] of state.extrasByName.entries()) {
    if (usedExtraKeys.has(key)) continue;

    const fallbackValue = parseInt(extra.sellPrice.replace(/[^0-9]/g, ""), 10) || 0;
    const customItem = {
      id: null,
      name: extra.name || "(Unknown Item)",
      rarity: extra.rarity || "",
      value: fallbackValue,
      itemType: extra.category || "",
      workbench: "",
      flavorText: "",
      lootArea: "",

      recycle1: extra.recycle1 || "",
      recycle2: extra.recycle2 || "",
      extraNotes: extra.notes || ""
    };

    mergedItems.push(customItem);
    state.itemByName.set(key, customItem);
  }

  state.items = mergedItems;
}

// Build quest indexes: robust against different JSON shapes
function buildQuestIndex(questsJson) {
  let quests = [];

  // Support both { data:[...] } and [...] at top level
  if (Array.isArray(questsJson?.data)) {
    quests = questsJson.data;
  } else if (Array.isArray(questsJson)) {
    quests = questsJson;
  } else if (Array.isArray(questsJson?.results)) {
    quests = questsJson.results;
  }

  if (!quests.length) {
    console.warn("Quest JSON not in expected format or empty:", questsJson);
    return;
  }

  console.log("Sample quest object from quests.json:", quests[0]);

  const idReqMap   = new Map();
  const idRewMap   = new Map();
  const nameReqMap = new Map();
  const nameRewMap = new Map();

  function addToMap(map, key, value) {
    if (!key) return;
    const list = map.get(key) || [];
    list.push(value);
    map.set(key, list);
  }

  function processItemArray(arr, questName, questSlug, isReward) {
    if (!Array.isArray(arr)) return;

    for (const entry of arr) {
      if (!entry) continue;

      // Try multiple possible field names
      const itemObj = entry.item || entry.target || null;
      const itemId =
        entry.item_id ||
        entry.itemId ||
        (itemObj && (itemObj.id || itemObj.slug || itemObj.item_id)) ||
        entry.id ||
        null;

      const itemName =
        (itemObj && itemObj.name) ||
        entry.name ||
        null;

      let qty = entry.quantity ?? entry.qty ?? entry.amount ?? null;
      if (typeof qty === "string") {
        const parsed = parseFloat(qty);
        if (!isNaN(parsed)) qty = parsed;
      }

      const value = { questName, questSlug, quantity: qty };

      if (isReward) {
        if (itemId)   addToMap(idRewMap, itemId, value);
        if (itemName) addToMap(nameRewMap, normalizeName(itemName), value);
      } else {
        if (itemId)   addToMap(idReqMap, itemId, value);
        if (itemName) addToMap(nameReqMap, normalizeName(itemName), value);
      }
    }
  }

  for (const quest of quests) {
    const questSlug = quest.id || quest.slug || slugifyName(quest.name || "");
    const questName = quest.name || quest.title || questSlug;

    // Required items: support several possible keys
    const requiredArrays = [];
    if (Array.isArray(quest.required_items)) requiredArrays.push(quest.required_items);
    if (Array.isArray(quest.requiredItems))  requiredArrays.push(quest.requiredItems);
    if (Array.isArray(quest.requirements))   requiredArrays.push(quest.requirements);

    for (const arr of requiredArrays) {
      processItemArray(arr, questName, questSlug, false);
    }

    // Rewards: support several possible keys
    const rewardArrays = [];
    if (Array.isArray(quest.rewards))       rewardArrays.push(quest.rewards);
    if (Array.isArray(quest.reward_items))  rewardArrays.push(quest.reward_items);

    for (const arr of rewardArrays) {
      processItemArray(arr, questName, questSlug, true);
    }
  }

  state.itemIdToRequiredQuests   = idReqMap;
  state.itemIdToRewardQuests     = idRewMap;
  state.itemNameToRequiredQuests = nameReqMap;
  state.itemNameToRewardQuests   = nameRewMap;

  console.log("Quest index built. Items with requirements:", idReqMap.size || nameReqMap.size);
}

/**
 * IMPORTANT NOTES LOADING
 */

async function ensureNotesLoaded() {
  if (state.notesLoaded || state.notesError || !NOTES_CSV_URL) return;

  try {
    const text = await fetchTextSafe(NOTES_CSV_URL);
    if (!text) {
      state.notesError = "Error loading Important Notes from the spreadsheet.";
      return;
    }

    const rows = text.replace(/\r/g, "").split("\n");
    state.importantNotes = [];

    for (const row of rows) {
      if (!row.trim()) continue;
      const fields = csvSplit(row);
      const note = (fields[0] || "").trim();
      if (note) {
        state.importantNotes.push(note);
      }
    }

    state.notesLoaded = true;
  } catch (err) {
    console.error(err);
    state.notesError = "Error loading Important Notes from the spreadsheet.";
  }
}

function renderNotesPanel() {
  if (!NOTES_CSV_URL) {
    dom.notesContent.innerHTML =
      '<div class="error">NOTES_CSV_URL is not set yet. Publish your "Important Notes" tab and paste its CSV link into the script.</div>';
    return;
  }

  if (state.notesError) {
    dom.notesContent.innerHTML = '<div class="error">' + escapeHtml(state.notesError) + '</div>';
    return;
  }

  if (!state.notesLoaded) {
    dom.notesContent.textContent = "Loading…";
    return;
  }

  if (!state.importantNotes.length) {
    dom.notesContent.textContent = "No notes found.";
    return;
  }

  const itemsHtml = state.importantNotes
    .map(n => '<div class="note-item">• ' + escapeHtml(n) + '</div>')
    .join("");
  dom.notesContent.innerHTML = itemsHtml;
}

/**
 * SEARCH + RENDER
 */

let searchDebounceTimer = null;

function runSearch(queryRaw) {
  const query = queryRaw.trim();
  const qNorm = normalizeName(query);

  dom.result.innerHTML = "";

  if (!state.dataLoaded) {
    dom.result.textContent = "Still loading data…";
    return;
  }

  if (!qNorm) {
    dom.result.textContent = "Type an item name above to search.";
    return;
  }

  const matches = state.items.filter(it =>
    normalizeName(it.name).includes(qNorm)
  );

  if (!matches.length) {
    dom.result.innerHTML = "<div>No match</div>";
    return;
  }

  matches.sort((a, b) => {
    const aName = normalizeName(a.name);
    const bName = normalizeName(b.name);
    const aStarts = aName.startsWith(qNorm) ? 0 : 1;
    const bStarts = bName.startsWith(qNorm) ? 0 : 1;
    if (aStarts !== bStarts) return aStarts - bStarts;
    return aName.localeCompare(bName);
  });

  let html = "";
  for (const item of matches) {
    html += renderItemBlock(item);
  }
  dom.result.innerHTML = html;
}

function renderItemBlock(item) {
  const rarityClr = rarityColor(item.rarity);
  const valueNum = Number(item.value) || 0;
  const valueText = valueNum ? valueNum.toLocaleString("en-US") : "";
  const valueClr = priceColor(valueNum);

  const itemUrl = item.id
    ? "https://metaforge.app/arc-raiders/database/item/" + encodeURIComponent(item.id)
    : null;

  const questUsage = getQuestUsageForItem(item);
  const questTagHtml = renderQuestTagCompact(questUsage.required);

  const recycledFrom = findRecyclersForItem(item.name);

  let html = '<div class="item-block">';

  // Title line
  html += '<div class="item-title">';
  if (itemUrl) {
    html += '<a class="item-link" href="' + itemUrl +
            '" target="_blank" rel="noopener noreferrer">' +
            '<span style="color:' + rarityClr + ';">' + escapeHtml(item.name) + "</span>" +
            "</a>";
  } else {
    html += '<span style="color:' + rarityClr + ';">' + escapeHtml(item.name) + "</span>";
  }

  if (valueText) {
    html += '<span class="item-value" style="color:' + valueClr + ';"> — ' +
            escapeHtml(valueText) + "</span>";
  }

  if (questTagHtml) {
    html += " " + questTagHtml;
  }

  html += "</div>";

  // Recycles To (sheet overlay)
  const recToParts = [];
  if (item.recycle1 && item.recycle1.trim()) recToParts.push(item.recycle1.trim());
  if (item.recycle2 && item.recycle2.trim()) recToParts.push(item.recycle2.trim());

  if (recToParts.length) {
    html += '<div class="line">Recycles To: ' +
            recToParts.map(escapeHtml).join(", ") + "</div>";
  }

  // Recycled From: white names + rarity letter + R-#
  if (recycledFrom.length) {
    html += '<div class="line" style="color:#ffa500;">Recycled From:</div>';
    for (const src of recycledFrom) {
      const letterInfo = rarityLetterAndColor(src.rarity);
      const srcValueNum = Number(src.value) || 0;
      const srcValueText = srcValueNum ? srcValueNum.toLocaleString("en-US") : "";
      const srcValueColor = priceColor(srcValueNum);
      const srcQuestUsage = getQuestUsageForItem(src);
      const srcQuestTagHtml = renderQuestTagCompact(srcQuestUsage.required);

      html += '<div class="line">';
      html += '<span style="color:#ffffff; font-weight:bold;">' +
              escapeHtml(src.name) + "</span>";
      html += '<span class="rarity-letter" style="color:' + letterInfo.color +
              ';">' + letterInfo.letter + "</span>";
      if (srcValueText) {
        html += ' — <span style="color:' + srcValueColor +
                '; font-weight:bold;">' + escapeHtml(srcValueText) + "</span>";
      }
      if (src.qty !== null) {
        html += ' <span class="line-small">R-' + src.qty + "</span>";
      }
      if (srcQuestTagHtml) {
        html += " " + srcQuestTagHtml;
      }
      html += "</div>";
    }
  }

  if (item.extraNotes) {
    html += '<div class="line">Notes: ' + escapeHtml(item.extraNotes) + "</div>";
  }

  html += "<hr></div>";
  return html;
}

// For a given item (not just id), look up quests by id and by name
function getQuestUsageForItem(item) {
  if (!item) return { required: [], reward: [] };

  let required = [];
  let reward = [];

  if (item.id) {
    required = state.itemIdToRequiredQuests.get(item.id) || [];
    reward   = state.itemIdToRewardQuests.get(item.id) || [];
  }

  if (!required.length && !reward.length) {
    const key = normalizeName(item.name);
    if (key) {
      required = state.itemNameToRequiredQuests.get(key) || required;
      reward   = state.itemNameToRewardQuests.get(key) || reward;
    }
  }

  return { required, reward };
}

// Render a compact quest tag
function renderQuestTagCompact(requiredList) {
  if (!requiredList || !requiredList.length) return "";

  const parts = requiredList.map(q => {
    const qtyText = q.quantity ? " (x" + q.quantity + ")" : "";
    const questUrl =
      "https://metaforge.app/arc-raiders/database/quest/" + encodeURIComponent(q.questSlug);
    return '<a href="' + questUrl +
           '" target="_blank" rel="noopener noreferrer" class="quest-link">' +
           escapeHtml(q.questName + qtyText) + "</a>";
  });

  return '<span class="quest-tag">[Needed for: ' + parts.join(", ") + "]</span>";
}

// Find items that recycle into the target item (using sheet overlay)
function findRecyclersForItem(targetName) {
  const targetKey = normalizeName(targetName);
  const results = [];

  for (const item of state.items) {
    const candidate = { id: item.id, name: item.name, rarity: item.rarity, value: item.value };

    const entries = [item.recycle1, item.recycle2];
    let totalQty = 0;
    let hasMatch = false;

    for (const entry of entries) {
      const parsed = parseRecycleEntry(entry);
      if (!parsed) continue;
      const entryKey = normalizeName(parsed.itemName);
      if (!entryKey || entryKey !== targetKey) continue;

      hasMatch = true;
      if (parsed.qty) {
        totalQty += parsed.qty;
      }
    }

    if (hasMatch) {
      results.push({
        ...candidate,
        qty: totalQty || null
      });
    }
  }

  return results;
}

/**
 * UI HANDLERS
 */

function attachEventHandlers() {
  // Typing in search
  dom.search.addEventListener("input", () => {
    const value = dom.search.value;

    if (!value.trim()) {
      dom.result.textContent = "Type an item name above to search.";
      setTopButtonsVisible(true);
      setInstructionsVisible(false);
      return;
    }

    setTopButtonsVisible(false);
    setInstructionsVisible(true);

    clearTimeout(searchDebounceTimer);
    searchDebounceTimer = setTimeout(() => {
      runSearch(value);
    }, 120);
  });

  // On focus: clear and reset UI
  dom.search.addEventListener("focus", () => {
    if (dom.search.value) {
      dom.search.value = "";
    }
    dom.result.textContent = "Type an item name above to search.";
    setTopButtonsVisible(true);
    setInstructionsVisible(false);
  });

  // Clear button
  dom.clearSearch.addEventListener("click", () => {
    dom.search.value = "";
    dom.search.focus();
    dom.result.textContent = "Type an item name above to search.";
    setTopButtonsVisible(true);
    setInstructionsVisible(false);
  });

  // Important Notes toggle
  dom.notesToggle.addEventListener("click", async () => {
    const isHidden = dom.notesPanel.classList.contains("hidden");
    if (isHidden) {
      await ensureNotesLoaded();
      renderNotesPanel();
      dom.notesPanel.classList.remove("hidden");
    } else {
      dom.notesPanel.classList.add("hidden");
    }
  });
}

function setTopButtonsVisible(visible) {
  if (visible) dom.topButtons.classList.remove("hidden");
  else dom.topButtons.classList.add("hidden");
}

function setInstructionsVisible(visible) {
  if (visible) dom.instructions.classList.remove("hidden");
  else dom.instructions.classList.add("hidden");
}

/**
 * BOOTSTRAP
 */
init();
</script>
</body>
</html>
