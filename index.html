<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ARC Lookup</title>

  <!-- MetaForge tooltips script (for item/quest hover tooltips) -->
  <script async src="https://cdn.metaforge.app/arcraiders-tooltips.min.js"></script>

  <style>
    body {
      background:#000;
      color:#fff;
      font-family:Segoe UI, sans-serif;
      padding:20px;
      max-width:900px;
      margin:0 auto;
    }

    .top-buttons {
      display:flex;
      gap:10px;
      margin-bottom:15px;
      flex-wrap:wrap;
    }
    .top-buttons a,
    .top-buttons button {
      background:#222;
      color:#fff;
      border:1px solid #444;
      border-radius:6px;
      padding:6px 12px;
      font-size:14px;
      text-decoration:none;
      cursor:pointer;
    }
    .top-buttons a:hover,
    .top-buttons button:hover {
      background:#333;
    }

    .search-row {
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }

    #search {
      font-size:22px;
      padding:12px;
      flex:1;
    }

    #clear-search {
      font-size:18px;
      padding:10px 14px;
      border-radius:6px;
      border:1px solid #444;
      background:#222;
      color:#fff;
      cursor:pointer;
    }
    #clear-search:hover {
      background:#333;
    }

    .instructions {
      background:#111;
      border:1px solid #333;
      border-radius:8px;
      padding:10px 12px;
      font-size:13px;
      margin-bottom:12px;
    }
    .instructions-title {
      font-weight:bold;
      margin-bottom:4px;
    }
    .instructions-row {
      margin:3px 0;
    }
    .pill {
      display:inline-block;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid #444;
      margin-left:4px;
      font-size:12px;
    }

    /* Rarity color pills (match item title colors) */
    .pill-common   { color:#ffffff; }
    .pill-uncommon { color:#00ff00; }
    .pill-rare     { color:#00bfff; }
    .pill-epic     { color:#ff00ff; }
    .pill-legendary{ color:#ffd700; }

    /* Value color pills (match price color logic) */
    .pill-price-1  { color:#ffffff; } /* <= 1000 */
    .pill-price-2  { color:#00ff00; } /* 1001–2000 */
    .pill-price-3  { color:#ff69b4; } /* 2001–5000 */
    .pill-price-4  { color:#ffd700; } /* 5001+ */

    .hidden {
      display:none !important;
    }

    .item-block {
      margin:10px 0 14px 0;
    }

    .item-title {
      font-size:26px;
      font-weight:bold;
      margin-bottom:4px;
    }

    .item-link {
      text-decoration:none;
    }

    .item-value {
      font-size:20px;
      margin-left:6px;
    }

    .quest-tag {
      font-size:16px;
      margin-left:8px;
      color:#ffd700;
    }

    .line {
      margin:4px 0;
      font-size:18px;
    }

    .line-small {
      font-size:14px;
      color:#ccc;
    }

    .rarity-letter {
      display:inline-block;
      width:18px;
      text-align:center;
      margin-left:4px;
      font-weight:bold;
    }

    .notes-panel {
      background:#111;
      border:1px solid #333;
      border-radius:8px;
      padding:10px 12px;
      margin-bottom:12px;
      font-size:14px;
    }

    .notes-panel h2 {
      margin-top:0;
      font-size:18px;
    }

    .note-item {
      margin:4px 0;
    }

    hr {
      border:1px solid #333;
      margin:10px 0;
    }

    .error {
      color:#ff6666;
    }

    footer {
      margin-top:16px;
      font-size:12px;
      color:#888;
    }
    footer a {
      color:#66b3ff;
    }
  </style>
</head>
<body>
  <div class="top-buttons" id="topButtons">
    <a href="https://mapgenie.io/arc-raiders" target="_blank" rel="noopener noreferrer">Maps</a>
    <a href="https://docs.google.com/spreadsheets/d/1FYBQG7Zq-hb-73baiUtMGrUUUjtif3mbBUZcpHN2X3U/edit?gid=732163012#gid=732163012"
       target="_blank" rel="noopener noreferrer">Spreadsheet</a>
    <button type="button" id="notesToggle">Important Notes</button>
  </div>

  <div class="search-row">
    <input id="search" placeholder="Type item name..." autofocus>
    <button id="clear-search" type="button" aria-label="Clear search">×</button>
  </div>

  <!-- Shown only when there is text in the search box -->
  <div id="instructions" class="instructions hidden">
    <div class="instructions-title">How to read the colors</div>
    <div class="instructions-row">
      Item name (rarity):
      <span class="pill pill-common">Common</span>
      <span class="pill pill-uncommon">Uncommon</span>
      <span class="pill pill-rare">Rare</span>
      <span class="pill pill-epic">Epic</span>
      <span class="pill pill-legendary">Legendary</span>
    </div>
    <div class="instructions-row">
      Sell value:
      <span class="pill pill-price-1">≤ 1000</span>
      <span class="pill pill-price-2">1001–2000</span>
      <span class="pill pill-price-3">2001–5000</span>
      <span class="pill pill-price-4">5001+</span>
    </div>
    <div class="instructions-row">
      R / S tags:
      <span class="pill">R-# = from recycling · S-# = from salvaging</span>
    </div>
  </div>

  <!-- Important Notes (Google Sheet "Important Notes" tab) -->
  <div id="notesPanel" class="notes-panel hidden">
    <h2>Important Notes</h2>
    <div id="notesContent">Loading…</div>
  </div>

  <div id="result"></div>

  <footer>
    Data from the
    <a href="https://metaforge.app/arc-raiders" target="_blank" rel="noopener noreferrer">MetaForge ARC Raiders</a>
    API &amp; your Google Sheet.
  </footer>

<script>
"use strict";

/**
 * -----------------------------
 *  CONFIGURATION
 * -----------------------------
 *
 * ITEMS_API_URL / QUESTS_API_URL:
 *   - Live data from MetaForge (items + quests).
 * EXTRA_CSV_URL:
 *   - Your existing sheet with columns:
 *     name, rarity, recycle1, recycle2, sellPrice, category, keep1, keep2, keep3, notes
 *   - We now use this ONLY for recycleX + notes (rarity/value come from API when available).
 * NOTES_CSV_URL:
 *   - A separate "Publish to web" CSV URL for the "Important Notes" tab.
 *   - Column A: each row = one note (A1, A2, A3, ...).
 */
const ITEMS_API_URL = "./items.json";
const QUESTS_API_URL = "./quests.json";

// Your original published CSV for item extras (recycles, notes, etc.)
const EXTRA_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ8XIQtZGS9iURh9D5oWsgyyBMqNJkLy9x0olt6DKKlCHevSpZ3qQevYZjrpctOLjOUyDFv1HEjkqGq/pub?output=csv";

// TODO: Replace this with the CSV "Publish to web" link for the "Important Notes" tab.
// Example format (once you publish that tab): 
//   https://docs.google.com/spreadsheets/d/e/XXXXXX/pub?gid=YYYYY&single=true&output=csv
const NOTES_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ8XIQtZGS9iURh9D5oWsgyyBMqNJkLy9x0olt6DKKlCHevSpZ3qQevYZjrpctOLjOUyDFv1HEjkqGq/pub?gid=732163012&single=true&output=csv"; // <-- fill this in once you publish the Important Notes tab

/**
 * -----------------------------
 *  GLOBAL STATE
 * -----------------------------
 */

const state = {
  items: [],                   // merged item objects (API + sheet overlay)
  itemByName: new Map(),       // name (normalized) -> item
  extrasByName: new Map(),     // name (normalized) -> extra row from sheet
  itemIdToRequiredQuests: new Map(), // item_id -> [{ questName, questSlug, quantity }]
  itemIdToRewardQuests: new Map(),   // item_id -> [{ questName, questSlug, quantity }]
  importantNotes: [],          // array of strings from Important Notes tab
  dataLoaded: false,
  notesLoaded: false,
  notesError: null
};

// Simple DOM cache
const dom = {
  search:       document.getElementById("search"),
  clearSearch:  document.getElementById("clear-search"),
  topButtons:   document.getElementById("topButtons"),
  instructions: document.getElementById("instructions"),
  result:       document.getElementById("result"),
  notesPanel:   document.getElementById("notesPanel"),
  notesContent: document.getElementById("notesContent"),
  notesToggle:  document.getElementById("notesToggle")
};

/**
 * -----------------------------
 *  UTILITY HELPERS
 * -----------------------------
 */

// Normalize item names for matching (case + whitespace).
function normalizeName(str) {
  return (str || "").trim().toLowerCase();
}

// Basic HTML escaping to avoid issues with special characters.
function escapeHtml(str) {
  return (str || "").replace(/[&<>"']/g, ch => {
    switch (ch) {
      case "&": return "&amp;";
      case "<": return "&lt;";
      case ">": return "&gt;";
      case '"': return "&quot;";
      case "'": return "&#39;";
      default:  return ch;
    }
  });
}

// Parse a CSV line into fields. Handles quoted fields with commas.
function csvSplit(row) {
  const out = [];
  let field = "";
  let inQuotes = false;

  for (const ch of row) {
    if (ch === '"') {
      inQuotes = !inQuotes;
      continue;
    }
    if (ch === "," && !inQuotes) {
      out.push(field);
      field = "";
      continue;
    }
    field += ch;
  }
  out.push(field);
  return out;
}

// Rarity color used for item title text and rarity letters.
function rarityColor(rarity) {
  const r = (rarity || "").toLowerCase();
  if (r.includes("uncommon"))  return "#00ff00";
  if (r.includes("rare"))      return "#00bfff";
  if (r.includes("epic"))      return "#ff00ff";
  if (r.includes("legendary")) return "#ffd700";
  return "#ffffff"; // common / unknown
}

// Single-letter code and color for rarity badges on "Recycled From".
function rarityLetterAndColor(rarity) {
  const r = (rarity || "").toLowerCase();
  if (r.includes("legendary")) return { letter: "L", color: "#ffd700" };
  if (r.includes("epic"))      return { letter: "E", color: "#ff00ff" };
  if (r.includes("rare"))      return { letter: "R", color: "#00bfff" };
  if (r.includes("uncommon"))  return { letter: "U", color: "#00ff00" };
  return { letter: "C", color: "#ffffff" }; // Common / default
}

// Value color based on coin range.
//  <=1000: white
// 1001–2000: green
// 2001–5000: pink
// 5001+: gold
function priceColor(value) {
  const n = Number(value) || 0;
  if (n <= 1000)  return "#ffffff";
  if (n <= 2000)  return "#00ff00";
  if (n <= 5000)  return "#ff69b4";
  return "#ffd700";
}

// Parse a recycle entry like "3 x Advanced Electrical Components"
// into { qty, itemName }.
// If parsing fails, qty will be null, itemName is the trimmed string.
function parseRecycleEntry(entry) {
  if (!entry) return null;
  const trimmed = entry.trim();
  if (!trimmed) return null;

  const m = trimmed.match(/^\s*(\d+)\s*x?\s*(.+)$/i);
  if (!m) {
    return { qty: null, itemName: trimmed };
  }
  return {
    qty: parseInt(m[1], 10),
    itemName: m[2].trim()
  };
}

/**
 * -----------------------------
 *  DATA LOADING
 * -----------------------------
 */

// Load everything we need on startup: items + quests + extra CSV.
// Important Notes are loaded lazily the first time the button is opened.
async function init() {
  dom.result.textContent = "Loading item data…";

  attachEventHandlers();

  try {
    const [itemsJson, questsJson, extraCsv] = await Promise.all([
      fetchJson(ITEMS_API_URL),
      fetchJson(QUESTS_API_URL),
      fetchTextSafe(EXTRA_CSV_URL)
    ]);

    if (extraCsv) {
      parseExtraCsv(extraCsv);
    }

    buildItemsFromApi(itemsJson);
    buildQuestIndex(questsJson);

    state.dataLoaded = true;
    dom.result.textContent = "Type an item name above to search.";
  } catch (err) {
    console.error(err);
    dom.result.innerHTML =
      '<div class="error">Error loading data from MetaForge or your sheet. Check console and URLs.</div>';
  }
}

// Generic JSON fetch helper with basic error handling.
async function fetchJson(url) {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error("Failed to fetch JSON: " + url + " (" + res.status + ")");
  }
  return res.json();
}

// Fetch text but return null instead of throwing on error.
// Used for overlay CSV so the page still works if sheet is misconfigured.
async function fetchTextSafe(url) {
  if (!url) return null;
  try {
    const res = await fetch(url);
    if (!res.ok) return null;
    return res.text();
  } catch {
    return null;
  }
}

// Parse overlay CSV (your existing sheet).
// Columns: 0 name, 1 rarity, 2 recycle1, 3 recycle2, 4 sellPrice, 5 category,
//          6 keep1, 7 keep2, 8 keep3, 9 notes
function parseExtraCsv(csvText) {
  const rows = csvText.replace(/\r/g, "").split("\n");
  rows.shift(); // drop header

  for (const row of rows) {
    if (!row.trim()) continue;
    const fields = csvSplit(row);

    const extra = {
      name:      fields[0] || "",
      rarity:    fields[1] || "",
      recycle1:  fields[2] || "",
      recycle2:  fields[3] || "",
      sellPrice: fields[4] || "",
      category:  fields[5] || "",
      keep1:     fields[6] || "",
      keep2:     fields[7] || "",
      keep3:     fields[8] || "",
      notes:     fields[9] || ""
    };

    const key = normalizeName(extra.name);
    if (!key) continue;
    state.extrasByName.set(key, extra);
  }
}

// Build main item list from MetaForge API and merge with extras from sheet.
function buildItemsFromApi(itemsJson) {
  const apiItems = Array.isArray(itemsJson?.data) ? itemsJson.data : [];

  const usedExtraKeys = new Set();
  const mergedItems = [];

  // 1) Items that exist in the API (primary source of truth)
  for (const it of apiItems) {
    const key = normalizeName(it.name);
    const extra = state.extrasByName.get(key);

    if (extra) {
      usedExtraKeys.add(key);
    }

    const merged = {
      // API core
      id: it.id,
      name: it.name,
      rarity: it.rarity || extra?.rarity || "",
      // MetaForge "value" is numeric. Fallback to sheet's sellPrice if missing.
      value: typeof it.value === "number" ? it.value :
             (extra ? parseInt(extra.sellPrice.replace(/[^0-9]/g, ""), 10) || 0 : 0),
      itemType: it.item_type || extra?.category || "",
      workbench: it.workbench || "",
      flavorText: it.flavor_text || "",
      lootArea: it.loot_area || "",

      // Overlay from sheet (manual data you control)
      recycle1: extra?.recycle1 || "",
      recycle2: extra?.recycle2 || "",
      extraNotes: extra?.notes || ""
    };

    mergedItems.push(merged);
    state.itemByName.set(key, merged);
  }

  // 2) Any extra rows that don't exist in the API (custom items, placeholders, etc.)
  for (const [key, extra] of state.extrasByName.entries()) {
    if (usedExtraKeys.has(key)) continue; // already merged

    const fallbackValue = parseInt(extra.sellPrice.replace(/[^0-9]/g, ""), 10) || 0;
    const customItem = {
      id: null,
      name: extra.name || "(Unknown Item)",
      rarity: extra.rarity || "",
      value: fallbackValue,
      itemType: extra.category || "",
      workbench: "",
      flavorText: "",
      lootArea: "",

      recycle1: extra.recycle1 || "",
      recycle2: extra.recycle2 || "",
      extraNotes: extra.notes || ""
    };

    mergedItems.push(customItem);
    state.itemByName.set(key, customItem);
  }

  state.items = mergedItems;
}

// Build quick lookup: item_id -> quests that require or reward that item.
function buildQuestIndex(questsJson) {
  const quests = Array.isArray(questsJson?.data) ? questsJson.data : [];

  const requiredMap = new Map();
  const rewardMap   = new Map();

  for (const quest of quests) {
    const questSlug = quest.id;   // used in /database/quest/<id>
    const questName = quest.name;

    // Required items for this quest
    if (Array.isArray(quest.required_items)) {
      for (const req of quest.required_items) {
        const itemId = req.item_id;
        const qty = Number(req.quantity) || null;
        if (!itemId) continue;

        const list = requiredMap.get(itemId) || [];
        list.push({
          questName,
          questSlug,
          quantity: qty
        });
        requiredMap.set(itemId, list);
      }
    }

    // Items rewarded by this quest
    if (Array.isArray(quest.rewards)) {
      for (const rw of quest.rewards) {
        const itemId = rw.item_id;
        const qty = Number(rw.quantity) || null;
        if (!itemId) continue;

        const list = rewardMap.get(itemId) || [];
        list.push({
          questName,
          questSlug,
          quantity: qty
        });
        rewardMap.set(itemId, list);
      }
    }
  }

  state.itemIdToRequiredQuests = requiredMap;
  state.itemIdToRewardQuests   = rewardMap;
}

/**
 * -----------------------------
 *  IMPORTANT NOTES LOADING
 * -----------------------------
 */

// Load Important Notes the first time the panel is opened.
async function ensureNotesLoaded() {
  if (state.notesLoaded || state.notesError || !NOTES_CSV_URL) return;

  try {
    const text = await fetchTextSafe(NOTES_CSV_URL);
    if (!text) {
      state.notesError = "Error loading Important Notes from the spreadsheet.";
      return;
    }

    const rows = text.replace(/\r/g, "").split("\n");
    state.importantNotes = [];

    for (const row of rows) {
      if (!row.trim()) continue;
      const fields = csvSplit(row);
      const note = (fields[0] || "").trim();
      if (note) {
        state.importantNotes.push(note);
      }
    }

    state.notesLoaded = true;
  } catch (err) {
    console.error(err);
    state.notesError = "Error loading Important Notes from the spreadsheet.";
  }
}

// Render the Important Notes panel from state.
function renderNotesPanel() {
  if (!NOTES_CSV_URL) {
    dom.notesContent.innerHTML =
      '<div class="error">NOTES_CSV_URL is not set yet. Publish your "Important Notes" tab and paste its CSV link into the script.</div>';
    return;
  }

  if (state.notesError) {
    dom.notesContent.innerHTML = '<div class="error">' + escapeHtml(state.notesError) + '</div>';
    return;
  }

  if (!state.notesLoaded) {
    dom.notesContent.textContent = "Loading…";
    return;
  }

  if (!state.importantNotes.length) {
    dom.notesContent.textContent = "No notes found.";
    return;
  }

  const itemsHtml = state.importantNotes
    .map(n => '<div class="note-item">• ' + escapeHtml(n) + '</div>')
    .join("");
  dom.notesContent.innerHTML = itemsHtml;
}

/**
 * -----------------------------
 *  SEARCH + RENDERING
 * -----------------------------
 */

let searchDebounceTimer = null;

// Main search entry point, called after debouncing.
function runSearch(queryRaw) {
  const query = queryRaw.trim();
  const qNorm = normalizeName(query);

  dom.result.innerHTML = "";

  if (!state.dataLoaded) {
    dom.result.textContent = "Still loading data…";
    return;
  }

  if (!qNorm) {
    dom.result.textContent = "Type an item name above to search.";
    return;
  }

  // Simple substring match on item name.
  const matches = state.items.filter(it =>
    normalizeName(it.name).includes(qNorm)
  );

  if (!matches.length) {
    dom.result.innerHTML = "<div>No match</div>";
    return;
  }

  // Prioritize items where the name starts with the query.
  matches.sort((a, b) => {
    const aName = normalizeName(a.name);
    const bName = normalizeName(b.name);
    const aStarts = aName.startsWith(qNorm) ? 0 : 1;
    const bStarts = bName.startsWith(qNorm) ? 0 : 1;
    if (aStarts !== bStarts) return aStarts - bStarts;
    return aName.localeCompare(bName);
  });

  let html = "";
  for (const item of matches) {
    html += renderItemBlock(item);
  }
  dom.result.innerHTML = html;
}

// Render a single item (title, quests, recycle info, notes).
function renderItemBlock(item) {
  const rarityClr = rarityColor(item.rarity);
  const valueNum = Number(item.value) || 0;
  const valueText = valueNum ? valueNum.toLocaleString("en-US") : "";
  const valueClr = priceColor(valueNum);

  const itemUrl = item.id
    ? "https://metaforge.app/arc-raiders/database/item/" + encodeURIComponent(item.id)
    : null;

  const questUsage = getQuestUsageForItem(item.id);
  const questTagHtml = renderQuestTagCompact(questUsage.required);

  // Reverse recycle lookup: items that recycle *into* this item.
  const recycledFrom = findRecyclersForItem(item.name);

  let html = '<div class="item-block">';

  // TITLE LINE
  html += '<div class="item-title">';
  if (itemUrl) {
    html += '<a class="item-link" href="' + itemUrl +
            '" target="_blank" rel="noopener noreferrer">' +
            '<span style="color:' + rarityClr + ';">' + escapeHtml(item.name) + "</span>" +
            "</a>";
  } else {
    html += '<span style="color:' + rarityClr + ';">' + escapeHtml(item.name) + "</span>";
  }

  if (valueText) {
    html += '<span class="item-value" style="color:' + valueClr + ';"> — ' +
            escapeHtml(valueText) + "</span>";
  }

  if (questTagHtml) {
    html += " " + questTagHtml;
  }

  html += "</div>";

  // Recycles To (sheet overlay)
  const recToParts = [];
  if (item.recycle1 && item.recycle1.trim()) recToParts.push(item.recycle1.trim());
  if (item.recycle2 && item.recycle2.trim()) recToParts.push(item.recycle2.trim());

  if (recToParts.length) {
    html += '<div class="line">Recycles To: ' +
            recToParts.map(escapeHtml).join(", ") + "</div>";
  }

  // Recycled From: each source item on its own line, with rarity letter + R-#.
  if (recycledFrom.length) {
    html += '<div class="line" style="color:#ffa500;">Recycled From:</div>';
    for (const src of recycledFrom) {
      const letterInfo = rarityLetterAndColor(src.rarity);
      const srcValueNum = Number(src.value) || 0;
      const srcValueText = srcValueNum ? srcValueNum.toLocaleString("en-US") : "";
      const srcValueColor = priceColor(srcValueNum);
      const srcQuestUsage = getQuestUsageForItem(src.id);
      const srcQuestTagHtml = renderQuestTagCompact(srcQuestUsage.required);

      html += '<div class="line">';
      html += '<span style="color:#ffffff; font-weight:bold;">' +
              escapeHtml(src.name) + "</span>";
      html += '<span class="rarity-letter" style="color:' + letterInfo.color +
              ';">' + letterInfo.letter + "</span>";
      if (srcValueText) {
        html += ' — <span style="color:' + srcValueColor +
                '; font-weight:bold;">' + escapeHtml(srcValueText) + "</span>";
      }
      if (src.qty !== null) {
        html += ' <span class="line-small">R-' + src.qty + "</span>";
      }
      if (srcQuestTagHtml) {
        html += " " + srcQuestTagHtml;
      }
      html += "</div>";
    }
  }

  // Notes from sheet overlay
  if (item.extraNotes) {
    html += '<div class="line">Notes: ' + escapeHtml(item.extraNotes) + "</div>";
  }

  // Future expansion lines (crafting breakdown, salvage, profit, etc.) would slot here.

  html += "<hr></div>";
  return html;
}

// For a given item id, return quests that require it and quests that reward it.
function getQuestUsageForItem(itemId) {
  if (!itemId) {
    return { required: [], reward: [] };
  }
  const required = state.itemIdToRequiredQuests.get(itemId) || [];
  const reward   = state.itemIdToRewardQuests.get(itemId) || [];
  return { required, reward };
}

// Render a compact quest tag, e.g. [Needed for: Building a Library (x3, x1…)]
function renderQuestTagCompact(requiredList) {
  if (!requiredList || !requiredList.length) return "";

  const parts = requiredList.map(q => {
    const qtyText = q.quantity ? " (x" + q.quantity + ")" : "";
    const questUrl =
      "https://metaforge.app/arc-raiders/database/quest/" + encodeURIComponent(q.questSlug);
    return '<a href="' + questUrl +
           '" target="_blank" rel="noopener noreferrer" class="quest-link">' +
           escapeHtml(q.questName + qtyText) + "</a>";
  });

  return '<span class="quest-tag">[Needed for: ' + parts.join(", ") + "]</span>";
}

// Find items that recycle into the target item, based on sheet overlay.
// Returns array of { id, name, rarity, value, qty }.
function findRecyclersForItem(targetName) {
  const targetKey = normalizeName(targetName);
  const results = [];

  for (const item of state.items) {
    const candidate = { id: item.id, name: item.name, rarity: item.rarity, value: item.value };

    const entries = [item.recycle1, item.recycle2];
    let totalQty = 0;
    let hasMatch = false;

    for (const entry of entries) {
      const parsed = parseRecycleEntry(entry);
      if (!parsed) continue;
      const entryKey = normalizeName(parsed.itemName);
      if (!entryKey || entryKey !== targetKey) continue;

      hasMatch = true;
      if (parsed.qty) {
        totalQty += parsed.qty;
      }
    }

    if (hasMatch) {
      results.push({
        ...candidate,
        qty: totalQty || null
      });
    }
  }

  return results;
}

/**
 * -----------------------------
 *  UI HANDLERS
 * -----------------------------
 */

function attachEventHandlers() {
  // Typing in search: debounce + hide/show UI elements.
  dom.search.addEventListener("input", () => {
    const value = dom.search.value;

    // If empty after typing, clear results and show top buttons again.
    if (!value.trim()) {
      dom.result.textContent = "Type an item name above to search.";
      setTopButtonsVisible(true);
      setInstructionsVisible(false);
      return;
    }

    setTopButtonsVisible(false);
    setInstructionsVisible(true);

    clearTimeout(searchDebounceTimer);
    searchDebounceTimer = setTimeout(() => {
      runSearch(value);
    }, 120);
  });

  // On focus: clear text AND clear results + show top buttons again.
  dom.search.addEventListener("focus", () => {
    if (dom.search.value) {
      dom.search.value = "";
    }
    dom.result.textContent = "Type an item name above to search.";
    setTopButtonsVisible(true);
    setInstructionsVisible(false);
  });

  // Clear button ("X") – mirrors the same behavior as clicking into the box but explicit.
  dom.clearSearch.addEventListener("click", () => {
    dom.search.value = "";
    dom.search.focus();
    dom.result.textContent = "Type an item name above to search.";
    setTopButtonsVisible(true);
    setInstructionsVisible(false);
  });

  // Important Notes toggle
  dom.notesToggle.addEventListener("click", async () => {
    const isHidden = dom.notesPanel.classList.contains("hidden");
    if (isHidden) {
      await ensureNotesLoaded();
      renderNotesPanel();
      dom.notesPanel.classList.remove("hidden");
    } else {
      dom.notesPanel.classList.add("hidden");
    }
  });
}

// Show / hide main top buttons (Maps, Spreadsheet, Important Notes).
function setTopButtonsVisible(visible) {
  if (visible) {
    dom.topButtons.classList.remove("hidden");
  } else {
    dom.topButtons.classList.add("hidden");
  }
}

// Show / hide the color instructions block.
function setInstructionsVisible(visible) {
  if (visible) {
    dom.instructions.classList.remove("hidden");
  } else {
    dom.instructions.classList.add("hidden");
  }
}

/**
 * -----------------------------
 *  BOOTSTRAP
 * -----------------------------
 */

init();
</script>
</body>
</html>

