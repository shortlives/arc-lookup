<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ARC Lookup</title>

  <!-- MetaForge tooltips script (for item/quest hover tooltips) -->
  <script async src="https://cdn.metaforge.app/arcraiders-tooltips.min.js"></script>

  <style>
    body {
      background:#000;
      color:#fff;
      font-family:Segoe UI, sans-serif;
      padding:20px;
      max-width:900px;
      margin:0 auto;
    }

    .top-buttons {
      display:flex;
      gap:10px;
      margin-bottom:15px;
      flex-wrap:wrap;
    }
    .top-buttons a,
    .top-buttons button {
      background:#222;
      color:#fff;
      border:1px solid #444;
      border-radius:6px;
      padding:6px 12px;
      font-size:14px;
      text-decoration:none;
      cursor:pointer;
    }
    .top-buttons a:hover,
    .top-buttons button:hover {
      background:#333;
    }

    .search-row {
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }

    #search {
      font-size:22px;
      padding:12px;
      flex:1;
    }

    #clear-search {
      font-size:18px;
      padding:10px 14px;
      border-radius:6px;
      border:1px solid #444;
      background:#222;
      color:#fff;
      cursor:pointer;
    }
    #clear-search:hover {
      background:#333;
    }

    .instructions {
      background:#111;
      border:1px solid #333;
      border-radius:8px;
      padding:10px 12px;
      font-size:13px;
      margin-bottom:12px;
    }
    .instructions-title {
      font-weight:bold;
      margin-bottom:4px;
    }
    .instructions-row {
      margin:3px 0;
    }
    .pill {
      display:inline-block;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid #444;
      margin-left:4px;
      font-size:12px;
    }

    /* Rarity color pills (match item title colors) */
    .pill-common   { color:#ffffff; }
    .pill-uncommon { color:#00ff00; }
    .pill-rare     { color:#00bfff; }
    .pill-epic     { color:#ff00ff; }
    .pill-legendary{ color:#ffd700; }

    /* Value color pills (match price color logic) */
    .pill-price-1  { color:#ffffff; } /* ≤ 1000 */
    .pill-price-2  { color:#00ff00; } /* 1001–2000 */
    .pill-price-3  { color:#ff69b4; } /* 2001–5000 */
    .pill-price-4  { color:#ffd700; } /* 5001+ */

    .hidden {
      display:none !important;
    }

    .item-block {
      margin:10px 0 14px 0;
    }

    .item-title {
      font-size:26px;
      font-weight:bold;
      margin-bottom:4px;
      display:flex;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
    }

    .item-link {
      text-decoration:none;
    }

    .item-value {
      font-size:20px;
      margin-left:6px;
    }

    .quest-tag {
      font-size:16px;
      margin-left:8px;
      color:#ffd700;
    }

    .line {
      margin:4px 0;
      font-size:18px;
    }

    .line-small {
      margin:3px 0;
      font-size:14px;
      color:#ccc;
    }

    /* Colored hyphen prefix on "Recycled From" lines */
    .rarity-prefix {
      display:inline-block;
      width:18px;
      text-align:center;
      margin-right:4px;
      font-weight:bold;
    }

    .notes-panel {
      background:#111;
      border:1px solid #333;
      border-radius:8px;
      padding:10px 12px;
      margin-bottom:12px;
      font-size:14px;
    }

    .notes-panel h2 {
      margin-top:0;
      font-size:18px;
    }

    .note-item {
      margin:4px 0;
    }

    hr {
      border:1px solid #333;
      margin:10px 0;
    }

    .error {
      color:#ff6666;
    }

    footer {
      margin-top:16px;
      font-size:12px;
      color:#888;
    }
    footer a {
      color:#66b3ff;
    }

    details summary {
      cursor:pointer;
    }

    .full-item-btn {
      background:#222;
      color:#fff;
      border:1px solid #444;
      border-radius:6px;
      padding:3px 8px;
      font-size:12px;
      cursor:pointer;
    }
    .full-item-btn:hover {
      background:#333;
    }
  </style>
</head>
<body>
  <div class="top-buttons" id="topButtons">
    <a href="https://mapgenie.io/arc-raiders" target="_blank" rel="noopener noreferrer">Maps</a>
    <a href="https://docs.google.com/spreadsheets/d/1FYBQG7Zq-hb-73baiUtMGrUUUjtif3mbBUZcpHN2X3U/edit?gid=732163012#gid=732163012"
       target="_blank" rel="noopener noreferrer">Spreadsheet</a>
    <button type="button" id="notesToggle">Important Notes</button>
  </div>

  <div class="search-row">
    <input id="search" placeholder="Type item name..." autofocus>
    <button id="clear-search" type="button" aria-label="Clear search">×</button>
  </div>

  <!-- Shown only when there is text in the search box -->
  <div id="instructions" class="instructions hidden">
    <div class="instructions-title">How to read the colors</div>
    <div class="instructions-row">
      Item Rarity:
      <span class="pill pill-common">Common</span>
      <span class="pill pill-uncommon">Uncommon</span>
      <span class="pill pill-rare">Rare</span>
      <span class="pill pill-epic">Epic</span>
      <span class="pill pill-legendary">Legendary</span>
    </div>
    <div class="instructions-row">
      Sell value:
      <span class="pill pill-price-1">≤ 1000</span>
      <span class="pill pill-price-2">1001–2000</span>
      <span class="pill pill-price-3">2001–5000</span>
      <span class="pill pill-price-4">5001+</span>
    </div>
  </div>

  <!-- Important Notes (Google Sheet "Important Notes" tab) -->
  <div id="notesPanel" class="notes-panel hidden">
    <h2>Important Notes</h2>
    <div id="notesContent">Loading…</div>
  </div>

  <div id="result"></div>

  <footer>
    Data from the
    <a href="https://metaforge.app/arc-raiders" target="_blank" rel="noopener noreferrer">MetaForge ARC Raiders</a>
    API &amp; your Google Sheet.
  </footer>

<script>
"use strict";

/**
 * CONFIGURATION
 *
 * items.json / quests.json should live in the same directory as this file.
 * EXTRA_CSV_URL is your existing "items" sheet (for recycle1/2 + notes).
 * NOTES_CSV_URL is the published CSV for your "Important Notes" tab.
 */
const ITEMS_API_URL  = "./items.json";
const QUESTS_API_URL = "./quests.json";

const EXTRA_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ8XIQtZGS9iURh9D5oWsgyyBMqNJkLy9x0olt6DKKlCHevSpZ3qQevYZjrpctOLjOUyDFv1HEjkqGq/pub?output=csv";

const NOTES_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ8XIQtZGS9iURh9D5oWsgyyBMqNJkLy9x0olt6DKKlCHevSpZ3qQevYZjrpctOLjOUyDFv1HEjkqGq/pub?gid=732163012&single=true&output=csv";

/**
 * FULL ITEM LOOKUP CONFIG
 * Toggle any of these to false if you want to hide that line in the
 * Full Item Lookup view.
 */
const FULL_LOOKUP_CONFIG = {
  showId:          true,
  showRarity:      true,
  showType:        true,
  showWorkbench:   true,
  showLootArea:    true,
  showSubcategory: true,
  showLoadout:     true,
  showDescription: true,
  showFlavor:      true,
  showStats:       true,
  showRawJson:     true
};

/**
 * GLOBAL STATE
 */
const state = {
  items: [],                         // merged item objects (API + sheet overlay)
  itemByName: new Map(),             // normalized name -> merged item
  extrasByName: new Map(),           // normalized name -> extra row from sheet
  apiItemsRaw: [],                   // raw API items from items.json
  apiItemsByName: new Map(),         // normalized name -> raw API item

  itemIdToRequiredQuests: new Map(),   // item id -> quest list
  itemIdToRewardQuests: new Map(),     // item id -> quest list
  itemNameToRequiredQuests: new Map(), // normalized item name -> quest list
  itemNameToRewardQuests: new Map(),   // normalized item name -> quest list

  importantNotes: [],
  dataLoaded: false,
  notesLoaded: false,
  notesError: null
};

// DOM cache
const dom = {
  search:        document.getElementById("search"),
  clearSearch:   document.getElementById("clear-search"),
  topButtons:    document.getElementById("topButtons"),
  instructions:  document.getElementById("instructions"),
  result:        document.getElementById("result"),
  notesPanel:    document.getElementById("notesPanel"),
  notesContent:  document.getElementById("notesContent"),
  notesToggle:   document.getElementById("notesToggle")
};

/**
 * UTILITIES
 */

function normalizeName(str) {
  return (str || "").trim().toLowerCase();
}

function slugifyName(str) {
  return (str || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function escapeHtml(str) {
  return (str || "").replace(/[&<>"']/g, ch => {
    switch (ch) {
      case "&": return "&amp;";
      case "<": return "&lt;";
      case ">": return "&gt;";
      case '"': return "&quot;";
      case "'": return "&#39;";
      default:  return ch;
    }
  });
}

function csvSplit(row) {
  const out = [];
  let field = "";
  let inQuotes = false;

  for (const ch of row) {
    if (ch === '"') {
      inQuotes = !inQuotes;
      continue;
    }
    if (ch === "," && !inQuotes) {
      out.push(field);
      field = "";
      continue;
    }
    field += ch;
  }
  out.push(field);
  return out;
}

function rarityColor(rarity) {
  const r = (rarity || "").toLowerCase();
  if (r.includes("uncommon"))  return "#00ff00";
  if (r.includes("rare"))      return "#00bfff";
  if (r.includes("epic"))      return "#ff00ff";
  if (r.includes("legendary")) return "#ffd700";
  return "#ffffff";
}

function priceColor(value) {
  const n = Number(value) || 0;
  if (n <= 1000)  return "#ffffff";
  if (n <= 2000)  return "#00ff00";
  if (n <= 5000)  return "#ff69b4";
  return "#ffd700";
}

function parseRecycleEntry(entry) {
  if (!entry) return null;
  const trimmed = entry.trim();
  if (!trimmed) return null;

  const m = trimmed.match(/^\s*(\d+)\s*x?\s*(.+)$/i);
  if (!m) {
    return { qty: null, itemName: trimmed };
  }
  return {
    qty: parseInt(m[1], 10),
    itemName: m[2].trim()
  };
}

/**
 * DATA LOADING
 */

async function init() {
  dom.result.textContent = "Loading item data…";

  attachEventHandlers();

  try {
    const [itemsJson, questsJson, extraCsv] = await Promise.all([
      fetchJson(ITEMS_API_URL),
      fetchJson(QUESTS_API_URL),
      fetchTextSafe(EXTRA_CSV_URL)
    ]);

    if (extraCsv) {
      parseExtraCsv(extraCsv);
    }

    buildItemsFromApi(itemsJson);
    buildQuestIndex(questsJson);

    state.dataLoaded = true;
    dom.result.textContent = "Type an item name above to search.";
  } catch (err) {
    console.error(err);
    dom.result.innerHTML =
      '<div class="error">Error loading data from items.json / quests.json or your sheet. Check the console and URLs.</div>';
  }
}

async function fetchJson(url) {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error("Failed to fetch JSON: " + url + " (" + res.status + ")");
  }
  return res.json();
}

async function fetchTextSafe(url) {
  if (!url) return null;
  try {
    const res = await fetch(url);
    if (!res.ok) return null;
    return res.text();
  } catch {
    return null;
  }
}

function parseExtraCsv(csvText) {
  const rows = csvText.replace(/\r/g, "").split("\n");
  rows.shift(); // header

  for (const row of rows) {
    if (!row.trim()) continue;
    const fields = csvSplit(row);

    const extra = {
      name:      fields[0] || "",
      rarity:    fields[1] || "",
      recycle1:  fields[2] || "",
      recycle2:  fields[3] || "",
      sellPrice: fields[4] || "",
      category:  fields[5] || "",
      keep1:     fields[6] || "",
      keep2:     fields[7] || "",
      keep3:     fields[8] || "",
      notes:     fields[9] || ""
    };

    const key = normalizeName(extra.name);
    if (!key) continue;
    state.extrasByName.set(key, extra);
  }
}

/**
 * Build merged item list from API + sheet overlay,
 * and also keep a separate map of raw API items for Full Item Lookup.
 */
function buildItemsFromApi(itemsJson) {
  const apiItems = Array.isArray(itemsJson?.data) ? itemsJson.data : [];

  state.apiItemsRaw = apiItems;
  state.apiItemsByName.clear();

  const usedExtraKeys = new Set();
  const mergedItems = [];

  for (const it of apiItems) {
    const key = normalizeName(it.name);
    if (key) {
      state.apiItemsByName.set(key, it);
    }

    const extra = state.extrasByName.get(key);
    if (extra) {
      usedExtraKeys.add(key);
    }

    const merged = {
      // API core fields we use in normal search
      id: it.id,
      name: it.name,
      rarity: it.rarity || extra?.rarity || "",
      value: typeof it.value === "number"
        ? it.value
        : (extra ? parseInt(extra.sellPrice.replace(/[^0-9]/g, ""), 10) || 0 : 0),
      itemType: it.item_type || extra?.category || "",
      workbench: it.workbench || "",
      flavorText: it.flavor_text || "",
      lootArea: it.loot_area || "",

      // Sheet overlay
      recycle1: extra?.recycle1 || "",
      recycle2: extra?.recycle2 || "",
      extraNotes: extra?.notes || ""
    };

    mergedItems.push(merged);
    state.itemByName.set(key, merged);
  }

  // Sheet-only items
  for (const [key, extra] of state.extrasByName.entries()) {
    if (usedExtraKeys.has(key)) continue;

    const fallbackValue = parseInt(extra.sellPrice.replace(/[^0-9]/g, ""), 10) || 0;
    const customItem = {
      id: null,
      name: extra.name || "(Unknown Item)",
      rarity: extra.rarity || "",
      value: fallbackValue,
      itemType: extra.category || "",
      workbench: "",
      flavorText: "",
      lootArea: "",

      recycle1: extra.recycle1 || "",
      recycle2: extra.recycle2 || "",
      extraNotes: extra.notes || ""
    };

    mergedItems.push(customItem);
    state.itemByName.set(key, customItem);
  }

  state.items = mergedItems;
}

/**
 * Robust quest-index builder
 */
function buildQuestIndex(questsJson) {
  let quests = [];

  if (Array.isArray(questsJson?.data)) {
    quests = questsJson.data;
  } else if (Array.isArray(questsJson)) {
    quests = questsJson;
  } else if (Array.isArray(questsJson?.results)) {
    quests = questsJson.results;
  }

  if (!quests.length) {
    console.warn("Quest JSON not in expected format or empty:", questsJson);
    return;
  }

  console.log("Sample quest object from quests.json:", quests[0]);

  const idReqMap   = new Map();
  const idRewMap   = new Map();
  const nameReqMap = new Map();
  const nameRewMap = new Map();

  function addToMap(map, key, value) {
    if (!key) return;
    const list = map.get(key) || [];
    list.push(value);
    map.set(key, list);
  }

  function processItemArray(arr, questName, questSlug, isReward) {
    if (!Array.isArray(arr)) return;

    for (const entry of arr) {
      if (!entry) continue;

      const itemObj = entry.item || entry.target || null;
      const itemId =
        entry.item_id ||
        entry.itemId ||
        (itemObj && (itemObj.id || itemObj.slug || itemObj.item_id)) ||
        entry.id ||
        null;

      const itemName =
        (itemObj && itemObj.name) ||
        entry.name ||
        null;

      let qty = entry.quantity ?? entry.qty ?? entry.amount ?? null;
      if (typeof qty === "string") {
        const parsed = parseFloat(qty);
        if (!isNaN(parsed)) qty = parsed;
      }

      const value = { questName, questSlug, quantity: qty };

      if (isReward) {
        if (itemId)   addToMap(idRewMap, itemId, value);
        if (itemName) addToMap(nameRewMap, normalizeName(itemName), value);
      } else {
        if (itemId)   addToMap(idReqMap, itemId, value);
        if (itemName) addToMap(nameReqMap, normalizeName(itemName), value);
      }
    }
  }

  for (const quest of quests) {
    const questSlug = quest.id || quest.slug || slugifyName(quest.name || "");
    const questName = quest.name || quest.title || questSlug;

    const requiredArrays = [];
    if (Array.isArray(quest.required_items)) requiredArrays.push(quest.required_items);
    if (Array.isArray(quest.requiredItems))  requiredArrays.push(quest.requiredItems);
    if (Array.isArray(quest.requirements))   requiredArrays.push(quest.requirements);

    for (const arr of requiredArrays) {
      processItemArray(arr, questName, questSlug, false);
    }

    const rewardArrays = [];
    if (Array.isArray(quest.rewards))       rewardArrays.push(quest.rewards);
    if (Array.isArray(quest.reward_items))  rewardArrays.push(quest.reward_items);

    for (const arr of rewardArrays) {
      processItemArray(arr, questName, questSlug, true);
    }
  }

  state.itemIdToRequiredQuests   = idReqMap;
  state.itemIdToRewardQuests     = idRewMap;
  state.itemNameToRequiredQuests = nameReqMap;
  state.itemNameToRewardQuests   = nameRewMap;

  console.log("Quest index built. Items with requirements:", idReqMap.size || nameReqMap.size);
}

/**
 * IMPORTANT NOTES LOADING
 */

async function ensureNotesLoaded() {
  if (state.notesLoaded || state.notesError || !NOTES_CSV_URL) return;

  try {
    const text = await fetchTextSafe(NOTES_CSV_URL);
    if (!text) {
      state.notesError = "Error loading Important Notes from the spreadsheet.";
      return;
    }

    const rows = text.replace(/\r/g, "").split("\n");
    state.importantNotes = [];

    for (const row of rows) {
      if (!row.trim()) continue;
      const fields = csvSplit(row);
      const note = (fields[0] || "").trim();
      if (note) {
        state.importantNotes.push(note);
      }
    }

    state.notesLoaded = true;
  } catch (err) {
    console.error(err);
    state.notesError = "Error loading Important Notes from the spreadsheet.";
  }
}

function renderNotesPanel() {
  if (!NOTES_CSV_URL) {
    dom.notesContent.innerHTML =
      '<div class="error">NOTES_CSV_URL is not set yet. Publish your "Important Notes" tab and paste its CSV link into the script.</div>';
    return;
  }

  if (state.notesError) {
    dom.notesContent.innerHTML = '<div class="error">' + escapeHtml(state.notesError) + '</div>';
    return;
  }

  if (!state.importantNotes.length) {
    dom.notesContent.textContent = "No notes found.";
    return;
  }

  const itemsHtml = state.importantNotes
    .map(n => '<div class="note-item">• ' + escapeHtml(n) + '</div>')
    .join("");
  dom.notesContent.innerHTML = itemsHtml;
}

/**
 * SEARCH + RENDER (normal ARC lookup)
 */

let searchDebounceTimer = null;

function runSearch(queryRaw) {
  const query = queryRaw.trim();
  const qNorm = normalizeName(query);

  dom.result.innerHTML = "";

  if (!state.dataLoaded) {
    dom.result.textContent = "Still loading data…";
    return;
  }

  if (!qNorm) {
    dom.result.textContent = "Type an item name above to search.";
    return;
  }

  const matches = state.items.filter(it =>
    normalizeName(it.name).includes(qNorm)
  );

  if (!matches.length) {
    dom.result.innerHTML = "<div>No match</div>";
    return;
  }

  matches.sort((a, b) => {
    const aName = normalizeName(a.name);
    const bName = normalizeName(b.name);
    const aStarts = aName.startsWith(qNorm) ? 0 : 1;
    const bStarts = bName.startsWith(qNorm) ? 0 : 1;
    if (aStarts !== bStarts) return aStarts - bStarts;
    return aName.localeCompare(bName);
  });

  let html = "";
  for (const item of matches) {
    html += renderItemBlock(item);
  }
  dom.result.innerHTML = html;
}

function renderItemBlock(item) {
  const rarityClr = rarityColor(item.rarity);
  const valueNum = Number(item.value) || 0;
  const valueText = valueNum ? valueNum.toLocaleString("en-US") : "";
  const valueClr = priceColor(valueNum);

  const itemUrl = item.id
    ? "https://metaforge.app/arc-raiders/database/item/" + encodeURIComponent(item.id)
    : null;

  const questUsage = getQuestUsageForItem(item);
  const questTagHtml = renderQuestTagCompact(questUsage.required);

  const recycledFrom = findRecyclersForItem(item.name);

  const hasApiDetails = state.apiItemsByName.has(normalizeName(item.name));

  let html = '<div class="item-block">';

  // Title line (with optional "Full Info" button for this main item)
  html += '<div class="item-title">';
  let titleInner = "";

  if (itemUrl) {
    titleInner += '<a class="item-link" href="' + itemUrl +
            '" target="_blank" rel="noopener noreferrer">' +
            '<span style="color:' + rarityClr + ';">' + escapeHtml(item.name) + "</span>" +
            "</a>";
  } else {
    titleInner += '<span style="color:' + rarityClr + ';">' + escapeHtml(item.name) + "</span>";
  }

  if (valueText) {
    titleInner += '<span class="item-value" style="color:' + valueClr + ';"> — ' +
            escapeHtml(valueText) + "</span>";
  }

  if (questTagHtml) {
    titleInner += " " + questTagHtml;
  }

  html += titleInner;

  if (hasApiDetails) {
    html += '<button type="button" class="full-item-btn" data-item-name="' +
            escapeHtml(item.name) + '">Full Info</button>';
  }

  html += "</div>";

  // Recycles To (sheet overlay)
  const recToParts = [];
  if (item.recycle1 && item.recycle1.trim()) recToParts.push(item.recycle1.trim());
  if (item.recycle2 && item.recycle2.trim()) recToParts.push(item.recycle2.trim());

  if (recToParts.length) {
    html += '<div class="line">Recycles To: ' +
            recToParts.map(escapeHtml).join(", ") + "</div>";
  }

  // Recycled From: colored hyphen + item name + R/S tags + price + (optional) quest tag
  if (recycledFrom.length) {
    html += '<div class="line" style="color:#ffa500;">Recycled From: ' +
            '<span class="line-small">R = Recycled, S = Salvaged</span>' +
            "</div>";

    for (const src of recycledFrom) {
      const rarityClrSrc = rarityColor(src.rarity);
      const srcValueNum = Number(src.value) || 0;
      const srcValueText = srcValueNum ? srcValueNum.toLocaleString("en-US") : "";
      const srcValueColor = priceColor(srcValueNum);
      const srcQuestUsage = getQuestUsageForItem(src);
      const srcQuestTagHtml = renderQuestTagCompact(srcQuestUsage.required);

      const rsParts = [];
      if (src.qty !== null) rsParts.push("R-" + src.qty);
      if (src.salvageQty != null) rsParts.push("S-" + src.salvageQty);

      html += '<div class="line">';
      // colored hyphen prefix
      html += '<span class="rarity-prefix" style="color:' + rarityClrSrc + ';">-</span>';
      // item name
      html += '<span style="color:#ffffff; font-weight:bold;">' +
              escapeHtml(src.name) + "</span>";
      // R/S tags (between name and value)
      if (rsParts.length) {
        html += ' <span class="line-small">' + rsParts.join(" · ") + "</span>";
      }
      // value
      if (srcValueText) {
        html += ' — <span style="color:' + srcValueColor +
                '; font-weight:bold;">' + escapeHtml(srcValueText) + "</span>";
      }
      // quest tag
      if (srcQuestTagHtml) {
        html += " " + srcQuestTagHtml;
      }
      html += "</div>";
    }
  }

  if (item.extraNotes) {
    html += '<div class="line">Notes: ' + escapeHtml(item.extraNotes) + "</div>";
  }

  html += "<hr></div>";
  return html;
}

function getQuestUsageForItem(item) {
  if (!item) return { required: [], reward: [] };

  let required = [];
  let reward = [];

  if (item.id) {
    required = state.itemIdToRequiredQuests.get(item.id) || [];
    reward   = state.itemIdToRewardQuests.get(item.id) || [];
  }

  if (!required.length && !reward.length) {
    const key = normalizeName(item.name);
    if (key) {
      required = state.itemNameToRequiredQuests.get(key) || required;
      reward   = state.itemNameToRewardQuests.get(key) || reward;
    }
  }

  return { required, reward };
}

function renderQuestTagCompact(requiredList) {
  if (!requiredList || !requiredList.length) return "";

  const parts = requiredList.map(q => {
    const qtyText = q.quantity ? " (x" + q.quantity + ")" : "";
    const questUrl =
      "https://metaforge.app/arc-raiders/database/quest/" + encodeURIComponent(q.questSlug);
    return '<a href="' + questUrl +
           '" target="_blank" rel="noopener noreferrer" class="quest-link">' +
           escapeHtml(q.questName + qtyText) + "</a>";
  });

  return '<span class="quest-tag">[Needed for: ' + parts.join(", ") + "]</span>";
}

function findRecyclersForItem(targetName) {
  const targetKey = normalizeName(targetName);
  const results = [];

  for (const item of state.items) {
    const candidate = { id: item.id, name: item.name, rarity: item.rarity, value: item.value };

    const entries = [item.recycle1, item.recycle2];
    let totalQty = 0;
    let hasMatch = false;

    for (const entry of entries) {
      const parsed = parseRecycleEntry(entry);
      if (!parsed) continue;
      const entryKey = normalizeName(parsed.itemName);
      if (!entryKey || entryKey !== targetKey) continue;

      hasMatch = true;
      if (parsed.qty) {
        totalQty += parsed.qty;
      }
    }

    if (hasMatch) {
      results.push({
        ...candidate,
        qty: totalQty || null
      });
    }
  }

  return results;
}

/**
 * FULL ITEM LOOKUP – by item name (per-item button)
 * Uses the same data items.json → API_Items is built from.
 */
function fullItemLookupByName(name) {
  if (!state.dataLoaded) {
    dom.result.textContent = "Still loading data…";
    return;
  }

  const key = normalizeName(name);
  const apiItem = state.apiItemsByName.get(key);

  if (!apiItem) {
    dom.result.innerHTML =
      '<div class="error">No API details found for "' + escapeHtml(name) +
      '" in items.json / API_Items.</div>';
    return;
  }

  dom.result.innerHTML = renderFullItemDetails(apiItem);
  setInstructionsVisible(false);
}

/**
 * Render a full-detail view for a raw API item (mirrors API_Items content).
 * Hides/shows sections based on FULL_LOOKUP_CONFIG.
 */
function renderFullItemDetails(apiItem) {
  const rarityClr = rarityColor(apiItem.rarity);
  const valueNum = apiItem.value != null ? Number(apiItem.value) : NaN;
  const valueText = !isNaN(valueNum) ? valueNum.toLocaleString("en-US") : "";
  const valueClr = priceColor(valueNum);
  const itemUrl = apiItem.id
    ? "https://metaforge.app/arc-raiders/database/item/" + encodeURIComponent(apiItem.id)
    : null;

  const statBlock = apiItem.stat_block || {};
  const statKeys = Object.keys(statBlock).sort();

  let html = '<div class="item-block">';

  // Title
  html += '<div class="item-title">';
  if (itemUrl) {
    html += '<a class="item-link" href="' + itemUrl +
            '" target="_blank" rel="noopener noreferrer">' +
            '<span style="color:' + rarityClr + ';">' + escapeHtml(apiItem.name) + "</span>" +
            "</a>";
  } else {
    html += '<span style="color:' + rarityClr + ';">' + escapeHtml(apiItem.name) + "</span>";
  }
  if (valueText) {
    html += '<span class="item-value" style="color:' + valueClr + ';"> — ' +
            escapeHtml(valueText) + "</span>";
  }
  html += "</div>";

  // Core meta
  if (FULL_LOOKUP_CONFIG.showId) {
    html += '<div class="line-small">ID: ' + escapeHtml(String(apiItem.id || "")) + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showRarity) {
    html += '<div class="line-small">Rarity: ' + escapeHtml(apiItem.rarity || "Unknown") + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showType) {
    html += '<div class="line-small">Type: ' + escapeHtml(apiItem.item_type || "Unknown") + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showWorkbench && apiItem.workbench) {
    html += '<div class="line-small">Workbench: ' + escapeHtml(apiItem.workbench) + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showLootArea && apiItem.loot_area) {
    html += '<div class="line-small">Loot Area: ' + escapeHtml(apiItem.loot_area) + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showSubcategory && apiItem.subcategory) {
    html += '<div class="line-small">Subcategory: ' + escapeHtml(apiItem.subcategory) + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showLoadout &&
      apiItem.loadout_slots && apiItem.loadout_slots.length) {
    html += '<div class="line-small">Loadout Slots: ' +
            escapeHtml(apiItem.loadout_slots.join(", ")) + "</div>";
  }

  if (FULL_LOOKUP_CONFIG.showDescription && apiItem.description) {
    html += '<div class="line-small"><strong>Description:</strong> ' +
            escapeHtml(apiItem.description) + "</div>";
  }
  if (FULL_LOOKUP_CONFIG.showFlavor && apiItem.flavor_text) {
    html += '<div class="line-small"><strong>Flavor:</strong> ' +
            escapeHtml(apiItem.flavor_text) + "</div>";
  }

  if (FULL_LOOKUP_CONFIG.showStats && statKeys.length) {
    html += '<div class="line"><strong>Stats</strong></div>';
    statKeys.forEach(key => {
      const val = statBlock[key];
      if (val === null || val === undefined || val === "") return;
      html += '<div class="line-small">' +
              "<strong>" + escapeHtml(key) + ":</strong> " +
              escapeHtml(String(val)) +
              "</div>";
    });
  }

  if (FULL_LOOKUP_CONFIG.showRawJson) {
    html += '<details class="line-small" style="margin-top:8px;">' +
            "<summary>Raw API data (items.json / API_Items)</summary>" +
            "<pre>" + escapeHtml(JSON.stringify(apiItem, null, 2)) + "</pre>" +
            "</details>";
  }

  html += "</div>";
  return html;
}

/**
 * UI HANDLERS
 */

function attachEventHandlers() {
  dom.search.addEventListener("input", () => {
    const value = dom.search.value;

    if (!value.trim()) {
      dom.result.textContent = "Type an item name above to search.";
      setTopButtonsVisible(true);
      setInstructionsVisible(false);
      return;
    }

    setTopButtonsVisible(false);
    setInstructionsVisible(true);

    clearTimeout(searchDebounceTimer);
    searchDebounceTimer = setTimeout(() => {
      runSearch(value);
    }, 120);
  });

  dom.search.addEventListener("focus", () => {
    if (dom.search.value) {
      dom.search.value = "";
    }
    dom.result.textContent = "Type an item name above to search.";
    setTopButtonsVisible(true);
    setInstructionsVisible(false);
  });

  dom.clearSearch.addEventListener("click", () => {
    dom.search.value = "";
    dom.search.focus();
    dom.result.textContent = "Type an item name above to search.";
    setTopButtonsVisible(true);
    setInstructionsVisible(false);
  });

  dom.notesToggle.addEventListener("click", async () => {
    const isHidden = dom.notesPanel.classList.contains("hidden");
    if (isHidden) {
      await ensureNotesLoaded();
      renderNotesPanel();
      dom.notesPanel.classList.remove("hidden");
    } else {
      dom.notesPanel.classList.add("hidden");
    }
  });

  // Event delegation for per-item "Full Info" buttons inside #result
  dom.result.addEventListener("click", (event) => {
    const btn = event.target.closest(".full-item-btn");
    if (!btn) return;
    const itemName = btn.getAttribute("data-item-name") || "";
    fullItemLookupByName(itemName);
  });
}

function setTopButtonsVisible(visible) {
  if (visible) dom.topButtons.classList.remove("hidden");
  else dom.topButtons.classList.add("hidden");
}

function setInstructionsVisible(visible) {
  if (visible) dom.instructions.classList.remove("hidden");
  else dom.instructions.classList.add("hidden");
}

/**
 * BOOTSTRAP
 */
init();
</script>
</body>
</html>
