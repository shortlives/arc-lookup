<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ARC Lookup</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!--
    External library: PapaParse for robust CSV parsing.
    This keeps our code simpler and more reliable than hand-rolled CSV parsing.
  -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    /* Basic page styling */
    body {
      background: #000;
      color: #fff;
      font-family: Segoe UI, sans-serif;
      padding: 20px;
    }

    /* Row of top navigation / utility buttons */
    .top-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .top-buttons a,
    .top-buttons button {
      background: #222;
      color: #fff;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 14px;
      text-decoration: none;
      cursor: pointer;
    }

    .top-buttons a:hover,
    .top-buttons button:hover {
      background: #333;
    }

    /* Container to keep search box and clear button on one line */
    .search-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    /* Main search input */
    .search-row input {
      font-size: 22px;
      padding: 12px;
      flex: 1;
      min-width: 0; /* prevent overflow in flex layout */
    }

    /* Clear ("X") button next to the search field */
    .clear-button {
      font-size: 22px;
      padding: 0 10px;
      background: #222;
      border: 1px solid #444;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      height: 48px;
      min-width: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .clear-button:hover {
      background: #333;
    }

    /* Explainer block for color-code meaning; shown only while searching */
    .instructions {
      font-size: 14px;
      margin-bottom: 10px;
      background: #111;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 8px 10px;
    }

    .instructions ul {
      margin: 4px 0 0 18px;
      padding: 0;
    }

    /* Title of the matched item */
    .item-title {
      font-size: 26px;
      font-weight: bold;
      margin-bottom: 4px;
    }

    /* Generic result lines under the title */
    .line {
      margin: 4px 0;
      font-size: 18px;
    }

    hr {
      border: 1px solid #333;
      margin: 10px 0;
    }

    /* Panel for global / team notes */
    #notesPanel {
      margin-top: 15px;
      font-size: 16px;
      background: #111;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 10px;
    }

    .note-entry {
      margin-bottom: 6px;
    }

    .note-entry strong {
      color: #ffd700;
    }
  </style>
</head>
<body>

  <!--
    Top navigation / utility buttons.
    These automatically hide while the user is actively searching.
  -->
  <div class="top-buttons" id="topButtons">
    <a href="https://mapgenie.io/arc-raiders" target="_blank">Maps</a>
    <a href="https://docs.google.com/spreadsheets/d/1FYBQG7Zq-hb-73baiUtMGrUUUjtif3mbBUZcpHN2X3U/edit?gid=732163012#gid=732163012"
       target="_blank">Spreadsheet</a>
    <!-- Button to show global / important notes from the "Important Notes" tab -->
    <button type="button" id="showNotesBtn">Important Notes</button>
  </div>

  <!-- Search row: search input + "clear" button -->
  <div class="search-row">
    <input id="search" placeholder="Type item name..." autofocus>
    <button type="button" id="clearSearch" class="clear-button" aria-label="Clear search">&times;</button>
  </div>

  <!-- Instructions about color coding, visible only while a query is active -->
  <div id="instructions" class="instructions" style="display:none;">
    <strong>How to read the colors:</strong>
    <ul>
      <li><strong>Item name color</strong> = rarity
        (Uncommon = green, Rare = blue, Epic = magenta, Legendary = gold).</li>
      <li><strong>Price color</strong>:
        White = under 1,000 &bullet;
        Green = 1,000–2,000 &bullet;
        Pink = 2,001–5,000 &bullet;
        Gold = 5,001+.</li>
      <li><strong>Quest tags</strong> in gold brackets show which quests need that item.</li>
      <li>Under <strong>Recycled From</strong>, each source shows how many of the searched item you get when recycling it.</li>
    </ul>
  </div>

  <!-- Main search result area -->
  <div id="result"></div>

  <!-- Panel for "Important Notes" (items people are searching for, etc.) -->
  <div id="notesPanel" style="display:none;"></div>

  <script>
    // ==============================
    // Configuration & shared state
    // ==============================

    /**
     * Public CSV URL for the main item data.
     * This is the already-published CSV endpoint you were using.
     */
    const ITEMS_CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ8XIQtZGS9iURh9D5oWsgyyBMqNJkLy9x0olt6DKKlCHevSpZ3qQevYZjrpctOLjOUyDFv1HEjkqGq/pub?output=csv";

    /**
     * CSV URL for the "Important Notes" tab.
     * This uses the sheet name "Important Notes" and the main doc ID:
     *   1FYBQG7Zq-hb-73baiUtMGrUUUjtif3mbBUZcpHN2X3U
     *
     * Requirements:
     *  - That tab must be accessible publicly (either "Anyone with link can view"
     *    or "Published to the web") so GitHub Pages can fetch it.
     *  - The tab should have at least:
     *      Column A: Title / Name (e.g., player)
     *      Column J (if using full layout) OR Column B: Note text
     */
    const IMPORTANT_NOTES_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1FYBQG7Zq-hb-73baiUtMGrUUUjtif3mbBUZcpHN2X3U/gviz/tq?tqx=out:csv&sheet=Important%20Notes";

    /**
     * Main in-memory cache of item rows from the primary sheet.
     * Each entry is:
     *  { name, rarity, recycle1, recycle2, sellPrice, category, keep1, keep2, keep3, notes }
     */
    const data = [];

    /**
     * In-memory cache of important notes from the "Important Notes" tab.
     * Each entry is:
     *  { title, text }
     */
    const notesData = [];

    // Debounce timer for search input.
    let searchTimer = null;

    // Track whether the notes panel is currently visible.
    let notesPanelVisible = false;

    // Track loading state for important notes.
    let notesLoaded = false;
    let notesLoadError = null;

    // ==============================
    // DOM element references
    // ==============================

    /** Main search input element */
    const searchInput = document.getElementById("search");

    /** Container that holds all rendered search results */
    const resultContainer = document.getElementById("result");

    /** Block that explains the color coding */
    const instructionsEl = document.getElementById("instructions");

    /** Group of top navigation buttons */
    const topButtonsEl = document.getElementById("topButtons");

    /** "X" button that clears the search field */
    const clearSearchBtn = document.getElementById("clearSearch");

    /** Button that toggles the Important Notes panel */
    const showNotesBtn = document.getElementById("showNotesBtn");

    /** Panel that displays important / team notes */
    const notesPanelEl = document.getElementById("notesPanel");

    // Ensure top buttons are visible on initial load.
    setTopButtonsVisible(true);

    // ==============================
    // Event handlers
    // ==============================

    /**
     * When the search input receives focus, clear its current value.
     * This makes it faster to run multiple searches in a row.
     */
    searchInput.addEventListener("focus", function () {
      this.value = "";
    });

    /**
     * Whenever the user types in the search input, debounce the call
     * to runSearch() so we do not re-run the filter logic on every keystroke.
     */
    searchInput.addEventListener("input", function () {
      const query = this.value.trim();

      // Cancel any pending search.
      clearTimeout(searchTimer);

      // Schedule the search a short time after the user stops typing.
      searchTimer = setTimeout(() => {
        runSearch(query);
      }, 100);
    });

    /**
     * Allow ESC to quickly clear the search and reset the view.
     */
    searchInput.addEventListener("keydown", function (event) {
      if (event.key === "Escape") {
        event.preventDefault();
        clearSearchField();
      }
    });

    /**
     * Clicking the clear button empties the search field, restores the
     * top buttons, hides instructions, and removes all current results.
     */
    clearSearchBtn.addEventListener("click", function () {
      clearSearchField();
    });

    /**
     * Clicking "Important Notes" toggles the notes panel.
     * The contents are driven from the "Important Notes" tab.
     */
    showNotesBtn.addEventListener("click", function () {
      notesPanelVisible = !notesPanelVisible;

      if (notesPanelVisible) {
        renderImportantNotes();
        notesPanelEl.style.display = "block";
      } else {
        notesPanelEl.style.display = "none";
      }
    });

    // ==============================
    // Data loading (Google Sheets)
    // ==============================

    /**
     * Fetch the CSV from Google Sheets for the main item data and parse it.
     * On success, populate the "data" array with normalized item objects.
     */
    fetch(ITEMS_CSV_URL)
      .then(response => response.text())
      .then(text => {
        // Use PapaParse for robust CSV parsing (handles quotes, commas, etc.).
        const parsed = Papa.parse(text, {
          header: false,       // sheet uses fixed column order, not header row
          skipEmptyLines: true // ignore completely empty lines
        });

        const rows = parsed.data;

        // Remove the first row, which contains column headings.
        if (rows.length > 0) {
          rows.shift();
        }

        // Map each raw row array into a structured object with named fields.
        rows.forEach(row => {
          data.push({
            name:      (row[0] || "").trim(),
            rarity:    (row[1] || "").trim(),
            recycle1:  (row[2] || "").trim(),
            recycle2:  (row[3] || "").trim(),
            sellPrice: (row[4] || "").trim(),
            category:  (row[5] || "").trim(),
            keep1:     (row[6] || "").trim(),
            keep2:     (row[7] || "").trim(),
            keep3:     (row[8] || "").trim(),
            notes:     (row[9] || "").trim()
          });
        });
      })
      .catch(err => {
        // If something goes wrong with the fetch/parse, show a friendly message.
        console.error("Failed to load item data from the spreadsheet:", err);
        resultContainer.innerHTML =
          "<div style='color:#ff5555;'>Error loading data from the spreadsheet.</div>";
      });

    /**
     * Preload the "Important Notes" data from the dedicated tab.
     * This runs once at startup so the data is ready when the button is clicked.
     */
    loadImportantNotesData();

    /**
     * Fetch the "Important Notes" tab and populate notesData.
     * Tries to interpret:
     *   - Column A as the title/name
     *   - Column J (index 9) as the note text if present
     *   - Otherwise falls back to Column B as the note text
     */
    function loadImportantNotesData() {
      fetch(IMPORTANT_NOTES_CSV_URL)
        .then(response => response.text())
        .then(text => {
          const parsed = Papa.parse(text, {
            header: false,
            skipEmptyLines: true
          });

          const rows = parsed.data;

          // Remove header row if present.
          if (rows.length > 0) {
            rows.shift();
          }

          rows.forEach(row => {
            const title = (row[0] || "").trim() || "Note";

            // Prefer column J (index 9) for "Notes" if it exists,
            // otherwise fall back to column B (index 1).
            const textCell =
              ((row[9] !== undefined ? row[9] : "") || "").toString().trim() ||
              ((row[1] !== undefined ? row[1] : "") || "").toString().trim();

            if (!textCell) {
              // If there's no actual note text, skip this row.
              return;
            }

            notesData.push({
              title,
              text: textCell
            });
          });

          notesLoaded = true;
        })
        .catch(err => {
          console.error("Failed to load Important Notes from the spreadsheet:", err);
          notesLoadError = err;
          notesLoaded = true;
        });
    }

    // ==============================
    // Helper functions
    // ==============================

    /**
     * Show or hide the top navigation buttons.
     * While the user is actively searching, we hide them to give
     * more vertical space and keep focus on results.
     */
    function setTopButtonsVisible(visible) {
      topButtonsEl.style.display = visible ? "flex" : "none";
    }

    /**
     * Centralized way to clear the search field and reset the UI:
     *  - Clears text
     *  - Clears results
     *  - Hides instructions
     *  - Restores top buttons
     *  - Re-focuses the input
     */
    function clearSearchField() {
      searchInput.value = "";
      runSearch("");     // handles instructions + top button visibility
      searchInput.focus();
    }

    /**
     * Given a recycle string (e.g. "2 x Some Item"), strip off any leading
     * quantity such as "2 x" and return just the item name ("Some Item").
     */
    function extractItemNameFromRecycle(str) {
      // Remove leading "<number> x " if present and trim whitespace.
      return str.replace(/^\s*\d+\s*x\s*/i, "").trim();
    }

    /**
     * Given a recycle string (e.g. "2 x Some Item"), extract the numeric
     * quantity of target items produced. If no quantity is specified, assume 1.
     */
    function extractQuantityFromRecycle(str) {
      const match = str.match(/^\s*(\d+)\s*x?/i);
      if (!match) {
        // No explicit quantity found; default to 1.
        return 1;
      }
      const qty = parseInt(match[1], 10);
      return Number.isNaN(qty) ? 1 : qty;
    }

    /**
     * Return a hex color representing rarity for the item's name.
     * Fallback is white when rarity does not match the known labels.
     */
    function rarityColor(rarity) {
      const r = rarity.toLowerCase();
      if (r.includes("uncommon")) return "#00ff00"; // green
      if (r.includes("rare"))     return "#1e90ff"; // blue
      if (r.includes("epic"))     return "#ff00ff"; // magenta
      if (r.includes("legendary"))return "#ffd700"; // gold
      return "white";
    }

    /**
     * Return a hex color for the price text based on numeric value.
     *  - white: under 1,000
     *  - green: 1,000–2,000
     *  - pink:  2,001–5,000
     *  - gold:  5,001+
     */
    function priceColorPick(priceNumber) {
      if (priceNumber >= 1000 && priceNumber <= 2000) return "#00ff00"; // green
      if (priceNumber >= 2001 && priceNumber <= 5000) return "#ff69b4"; // pink
      if (priceNumber >= 5001)                       return "#ffd700"; // gold
      return "white"; // under 1000
    }

    /**
     * Collect quest / usage names for an item from its keep1/keep2/keep3
     * fields and return them as an array of non-empty strings.
     */
    function getQuestNames(item) {
      const quests = [];

      if (item.keep1) quests.push(item.keep1.trim());
      if (item.keep2) quests.push(item.keep2.trim());
      if (item.keep3) quests.push(item.keep3.trim());

      return quests;
    }

    /**
     * For a given "source" item and a target item name, compute how many
     * of the target item you get when recycling the source.
     *
     * It checks both recycle1 and recycle2 fields; if both yield the same
     * target, their quantities are summed.
     *
     * @param {Object} srcItem    - source item (has recycle1/recycle2 fields)
     * @param {string} targetName - name of the item being searched
     * @returns {number|null} quantity of target produced or null if none
     */
    function getRecycleQuantityForTarget(srcItem, targetName) {
      const lowerTarget = targetName.toLowerCase();
      let totalQty = 0;

      ["recycle1", "recycle2"].forEach(key => {
        const raw = srcItem[key];
        if (!raw) return;

        const producedName = extractItemNameFromRecycle(raw).toLowerCase();

        if (producedName === lowerTarget) {
          totalQty += extractQuantityFromRecycle(raw);
        }
      });

      return totalQty > 0 ? totalQty : null;
    }

    // ==============================
    // Rendering functions
    // ==============================

    /**
     * Main search routine.
     *  - Filters items by name matching the query (case-insensitive).
     *  - Renders all matched items into the result container.
     *  - Shows/hides top buttons and instructions based on query presence.
     */
    function runSearch(query) {
      // Always clear existing results on each new search.
      resultContainer.innerHTML = "";

      const hasQuery = Boolean(query);

      // Show or hide top buttons and instructions depending on query.
      setTopButtonsVisible(!hasQuery);
      instructionsEl.style.display = hasQuery ? "block" : "none";

      // If query is empty after trimming, nothing else to do.
      if (!hasQuery) {
        return;
      }

      const lowerQuery = query.toLowerCase();

      // Filter items whose name includes the search text.
      const matches = data.filter(item =>
        item.name.toLowerCase().includes(lowerQuery)
      );

      if (!matches.length) {
        resultContainer.innerHTML = "<div>No match</div>";
        return;
      }

      // Build a single HTML string for all results to minimize DOM writes.
      let html = "";

      matches.forEach(item => {
        // Determine color for the item name based on rarity.
        const nameColor = rarityColor(item.rarity);

        // Parse numeric sell price from the raw string (strip non-digits).
        const priceNumber =
          parseInt(item.sellPrice.replace(/[^0-9]/g, ""), 10) || 0;

        // Determine color for the price based on numeric thresholds.
        const priceColor = priceColorPick(priceNumber);

        // Quest usage tag next to the title, using keep1/keep2/keep3.
        const questNames = getQuestNames(item);
        const questTag = questNames.length
          ? `<span style="color:#ffd700; font-size:18px; margin-left:10px;">[${questNames.join(", ")}]</span>`
          : "";

        // Build simple "Recycles To" text using recycle1 + recycle2 fields.
        const recycleTargets = [];
        if (item.recycle1) recycleTargets.push(item.recycle1);
        if (item.recycle2) recycleTargets.push(item.recycle2);

        // Find all other items that recycle into THIS item.
        const recyclers = data.filter(src => {
          const r1 = extractItemNameFromRecycle(src.recycle1 || "").toLowerCase();
          const r2 = extractItemNameFromRecycle(src.recycle2 || "").toLowerCase();
          const targetLower = item.name.toLowerCase();
          return r1 === targetLower || r2 === targetLower;
        });

        // =====================
        // Title line
        // =====================
        html += `
          <div class="item-title">
            <span style="color:${nameColor};">${item.name}</span>
            <span style="color:${priceColor}; font-size:20px;">— ${item.sellPrice}</span>
            ${questTag}
          </div>
        `;

        // =====================
        // "Recycles To" line
        // =====================
        if (recycleTargets.length) {
          html += `
            <div class="line">
              Recycles To: ${recycleTargets.join(", ")}
            </div>
          `;
        }

        // =====================
        // "Recycled From" section
        // =====================
        if (recyclers.length) {
          html += `
            <div class="line" style="color:#ffa500;">Recycled From:</div>
          `;

          recyclers.forEach(src => {
            const srcNameColor = rarityColor(src.rarity);

            const srcPriceNumber =
              parseInt(src.sellPrice.replace(/[^0-9]/g, ""), 10) || 0;

            const srcPriceColor = priceColorPick(srcPriceNumber);

            // Quest names for the source item.
            const srcQuestNames = getQuestNames(src);
            const srcQuestTag = srcQuestNames.length
              ? `<span style="color:#ffd700;"> [${srcQuestNames.join(", ")}]</span>`
              : "";

            // Quantity of the current item yielded when recycling this source.
            const qty = getRecycleQuantityForTarget(src, item.name);
            const qtyText = qty !== null
              ? `<span style="margin-left:8px; font-size:16px; color:#cccccc;">→ Yields ${qty}x ${item.name}</span>`
              : "";

            html += `
              <div class="line">
                <span style="color:${srcNameColor}; font-weight:bold;">${src.name}</span>
                —
                <span style="color:${srcPriceColor}; font-weight:bold;">${src.sellPrice}</span>
                ${srcQuestTag}
                ${qtyText}
              </div>
            `;
          });
        }

        // =====================
        // Notes line (if present)
        // =====================
        if (item.notes) {
          html += `
            <div class="line">
              Notes: ${item.notes}
            </div>
          `;
        }

        html += `<hr>`;
      });

      // Push the assembled HTML into the results container.
      resultContainer.innerHTML = html;
    }

    /**
     * Render the Important Notes panel using rows from the "Important Notes" tab.
     * Intended for things like "what items each player is searching for".
     */
    function renderImportantNotes() {
      // Handle load errors cleanly.
      if (notesLoadError) {
        notesPanelEl.innerHTML =
          "<div style='color:#ff5555;'>Error loading Important Notes from the spreadsheet.</div>";
        return;
      }

      // If the data has not loaded yet, let the user know.
      if (!notesLoaded) {
        notesPanelEl.innerHTML =
          "<div>Important Notes are still loading. Please try again in a moment.</div>";
        return;
      }

      if (!notesData.length) {
        notesPanelEl.innerHTML =
          "<div>No important notes are configured in the sheet yet.</div>";
        return;
      }

      // Build a small list of note entries.
      let html = "<div><strong>Important Notes</strong></div><br>";

      notesData.forEach(note => {
        html += `
          <div class="note-entry">
            <strong>${note.title}:</strong> ${note.text}
          </div>
        `;
      });

      notesPanelEl.innerHTML = html;
    }
  </script>
</body>
</html>
